---
layout: post
title: "C++回调函数引发的思考"
date: 2017-5-20 21:09:12 +0800
categories: C++
location: HangZhou,China
description:
---
---
今天在公司实习，领导为了让我熟悉公司底层服务端架构，让我花两天时间写一个基于当前平台多线程收发消息的Demo。我参考项目中的旧代码编写这个Demo，平台上有个接口是注册回调函数的，我参照接口函数参数类型一一编写，最后碰到一个编译错误，百思不得其解，后来是同事提醒这里需要加个static关键字，他说C++回调函数必须是static，我一脸茫然。他让我去看static关键的作用，我说我都知道呀，static嘛，balabala.....。他说对啊，所以这里要加static。我还是一脸茫然，为了不暴露我**菜**的事实，只好点头说是。下班后深究之下，终于发现了问题根源。同事说的也有失偏颇。

先看下面的例子:
### 普通的回调:
![普通回调函数](../material/CALLBACK/normal_callback.png)
很正常，函数正常运行。
### C++成员函数作为回调函数

现在我们来看，**当回调的函数是某个对象的成员函数的时候**

![C++回调](../material/CALLBACK/class_memberfunction.png)

我们编写类成员函数类型，和接口要求的回调函数参数类型**“完全一样”**,好，我们编译一下：

![C++回调编译结果](../material/CALLBACK/compile_error.png)

为什么会这样？函数指针不都只这么用的么，而且怎么还和static搭上了关系？根据编译器的提示，我上网找资料，终于发现了症结所在，算是今天最大的收获了！

### 找原因
要从C++对象模型说起，**this指针**。

1.我们知道C++的类成员函数中,默认都隐含了一个this指针,标识调用该成员函数的对象

2.为什么需要有一个this指针呢?C++设计这个机制的初衷是什么呢?

我们知道,普通的C++类,其成员函数是类的所有对象共享的,而数据时每个对象所独有的.即:**数据独有,方法共享**。因此在调用类的某个成员方法(非静态方法)时,我怎么知道是哪个对象调用的呢?此时就是通过this指针来区分的，通过this指针我可以区分是该类的哪个对象正在调用该成员方法。


