<?xml version="1.0" encoding="utf-8"?>
<ul>
  <li>卡尔曼增益简单介绍及推导有一把尺子测量一枚硬币的直径,记录每次测量出的结果(测量值):$x_1$,$x_2$,$x_3$,….那么,对硬币直径的估计值:$\overline{x}_n$=$\frac{(x_1+x_2+x_3+...+x_n)}{n}$进一步,写成递归形式:$\overline{x}_n$=$\overline{x}_{n-1}$+$\frac{1}{n}(x_n-\overline{x}_{n-1})$可见,随着${n\to+\infty}$,测量结果已经不再重要.文字表示为:当前的估计值=上一次的估计值+系数*(当前的测试量-上一次的估计值)假设要考虑上一次的估计误差和本次的测量误差,一个很直观的想法就是:如果估计误差大于测量误差,也就是说测量的更佳准确,那么当前的估计值应该偏向于本次的测量值如果估计误差小于测量误差,也就是说测量的不准确,那么当前的估计值应该偏向于上一次的估计值这就是数据融合的思想,此时,这个系数就是卡尔曼增益系数:对于一个确定性离散时间系统的状态方程:$x_{n+1}=Ax_n+Bu_k+w_k$,$w_k$表示过程噪声$y_n=Cx_n+v_k$,$v_k$表示测量误差那么，从数据融合的角度看，对于状态的估计其实就是：$\overline{x}{n+1}=\overline{x}^{calc}{n}+G(\overline{x}^{mess}_n-\overline{x}^{calc}_n)$进一步，对G做转换:$G=KC$我们称K是可以将测量值转换为真实值的卡尔曼增益,从而有:$\overline{x}{n+1}=\overline{x}^{mess}{calc}+K(y_k-C\overline{x}^{calc}_n)$那么，误差就可以表示为:$e_n=x_n-\overline{x}_n$$=x_n-\overline{x}^{calc}_n-K(Cx_n+v_k)+KC\overline{x}^{calc}_n$$=(I-KC)x_n-(I-KC)\overline{x}^{calc}_n-Kv_n$$=(I-KC)(x_n-\overline{x}^{calc}_n)-Kv_n$上述中的I代表单位矩阵，如果是1阶就是1，二阶则是2X2的单位矩阵需要假设这个误差满足正太分布:$e\simN(0,P_k)$$P_k$就是随机变量的方差，对于多维随机变量来说就是指协方差矩阵的迹（对角线元素之和），可以表示为:(证明略)$P_k=E[e_k*e^t_k]$,($e^t$表示矩阵的转置)带入各式:$P_k=E{(I-KC)(x_k-x^{calc}_k)-Kv_k}{(I-KC)(x_k-x^{calc}_k)-Kv_k}^T$将乘积展开，同时引入估计误差:$e_k=x_k-x^{calc}_k$最终:$P_k=(I-KC)E[e_k*e^t_k](I-KC)^t+KE[v_k*v^t_k]K^t$注意，上式中的$e_k$代表的是估计误差,将$E[e_k*e^t_k]记作\overline{P}_k$从而:$P_k=(\overline{P}_k-KC\overline{P}_k)(I-C^tK^T)+KRK^t,R=E[v_k*v^t_k]$我们要让误差最小,就是要让导数为0（且二次导小于0）,矩阵的求导过程略:$\frac{dP_k}{dK}=K(CP_kC^t+R)-P_kC^t=0$$K=\frac{P_kC^t}{CP_kC^t+R}$信道速率+排队时延的估计webrtc认为帧的抖动被认为是帧大小的变化引起的:$delay=Rate_{channel}*Delta_{frame}+Noise$,即信道速率*帧大小的变化+噪声webrtc使用卡尔曼滤波去估计信道速率和排队延迟,从而进一步确定jitter首先，建立数学模型，这是个二元系统，信道速率(R)+排队延迟(D)。从模型上说，这两个值当然是不变的，也即:$R_k=1*R_{k-1}+0$$D_k=1*D_{k-1}+0$系统的状态转换方程用矩阵可以表示为:$$\begin{bmatrix}RD\end{bmatrix}=\begin{bmatrix}1&amp;&amp;00&amp;&amp;1\end{bmatrix}\begin{bmatrix}R_{k_1}&amp;&amp;D_{k-1}\end{bmatrix}$$系统输出(只有一个jitter)用矩阵表示为:下面引入一条卡尔曼滤波中的公式，先验的误差协方差矩阵(证明略，还没学会):A就是系统的转换矩阵,那么就有:这时候，再看webrtc中的代码://Prediction//M=M+Q_thetaCov[0][0]+=_Qcov[0][0];_thetaCov[0][1]+=_Qcov[0][1];_thetaCov[1][0]+=_Qcov[1][0];_thetaCov[1][1]+=_Qcov[1][1];一样一样的。接着更新卡尔曼增益系数(第一部分已经给出证明):再对应源码,注意是二阶（R,D）:Mh[0]=_thetaCov[0][0]*deltaFSBytes+_thetaCov[0][1];Mh[1]=_thetaCov[1][0]*deltaFSBytes+_thetaCov[1][1];//sigmaweightsmeasurementswithasmalldeltaFSasnoisyand//measurementswithlargedeltaFSasgoodif(_maxFrameSize&lt;1.0){return;}doublesigma=(300.0*exp(-fabs(static_cast&lt;double&gt;(deltaFSBytes))/(1e0*_maxFrameSize))+1)*sqrt(_varNoise);if(sigma&lt;1.0){sigma=1.0;}hMh_sigma=deltaFSBytes*Mh[0]+Mh[1]+sigma;if((hMh_sigma&lt;1e-9&amp;&amp;hMh_sigma&gt;=0)||(hMh_sigma&gt;-1e-9&amp;&amp;hMh_sigma&lt;=0)){assert(false);return;}kalmanGain[0]=Mh[0]/hMh_sigma;kalmanGain[1]=Mh[1]/hMh_sigma;接下去，计算得到本次的最优估计值://Correction//theta=theta+K*(dT-h*theta)measureRes=frameDelayMS-(deltaFSBytes*_theta[0]+_theta[1]);_theta[0]+=kalmanGain[0]*measureRes;_theta[1]+=kalmanGain[1]*measureRes;继续引进卡尔曼公式2,更新先验误差协方差矩阵(证明略，还没有学会):对应源码://M=(I-K*h)*Mt00=_thetaCov[0][0];t01=_thetaCov[0][1];_thetaCov[0][0]=(1-kalmanGain[0]*deltaFSBytes)*t00-kalmanGain[0]*_thetaCov[1][0];_thetaCov[0][1]=(1-kalmanGain[0]*deltaFSBytes)*t01-kalmanGain[0]*_thetaCov[1][1];_thetaCov[1][0]=_thetaCov[1][0]*(1-kalmanGain[1])-kalmanGain[1]*deltaFSBytes*t00;_thetaCov[1][1]=_thetaCov[1][1]*(1-kalmanGain[1])-kalmanGain[1]*deltaFSBytes*t01;至此，一轮卡尔曼滤波结束.end本文详细证明了卡尔曼滤波算法公式中的卡尔曼增益系数，以及说明了系统转换方程、测量方程。对于先验误差公式以及误差协方差的更新公式未给出证明。并且未对webrtc中如何deltaF、noise进行说明(比较简单)。参考链接:https://zhuanlan.zhihu.com/p/33899560https://www.cnblogs.com/heguanyou/p/7502909.htmlhttps://zhuanlan.zhihu.com/p/165570020</li>
  <li>lea指令lea指令的解释是:loadeffectiveaddress.网上有很多解释,比如知乎高赞汇编语言中mov和lea的区别有哪些？:lea是“loadeffectiveaddress”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：leaeax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。而mov指令则恰恰相反，例如：moveax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。说的没错,可是仍旧是没有解释为什么用mov就不行,比如:leaeax,[ebx+8];将ebx+8这个值直接赋给eax难道不等价与:moveax,ebx+8;其实,这才是初学者真正想问的问题.原因也很搞笑:mov指令不支持这样的格式.上面的例子中,源操作数”ebx+8”isinvalid.</li>
  <li>###notes在8086处理器上,如果要用寄存器来提供偏移地址,只能使用BX,si,di,bP,不能使用其它寄存器.以下指令是非法的:mov[ax],dl8086处理器只支持以下几种基地址寄存器和变址寄存器的组合:[bx+si][bx+di][bp+si][bp+di]条件转移指令js当SF==1则跳转,jns与之相反jz当zF==1则跳转,jnz与之相反jo当OF==1则跳转,jno与之相反jc当CF==1则跳转,jnc与之相反jp当PF==1则跳转,jnp与之相反常用指令movsb|movsw```shellDS:SI–&gt;ES:DIDF=0low-&gt;highDF=1high-&gt;lowinstruction‘cld’cancleardf*divA/B.A是被除数,B是为除数.被除数A默认存在AX中,或者AX和DX中(DX存高x位)如果除数是8位，那么除法的结果AL保存商，AH保存余数.如果除数16位，那么除法的结果AX保存商，DX保存余数。*cli&amp;&amp;sti清除和设置IF(中断标志位)*repe/repne相等(ZF==0)/不相等的时候重复*scasb(w|d)两个对比数分别为EAX/AX/AL和DS:EDI,并且将edi-+1（2|4)###ret*ret弹栈到IP寄存器*retf弹栈到IP,再弹栈到CS*iret弹栈到IP,再弹栈到CS,再弹栈到FLAGS###call指令call指令有三种形式:第一种是16位相对近调用,近调用的意思是被调用的目标过程位于当前代码段内,而非另一个不同的代码段,所以只需要得到偏移地址即可.16位相对近调用是三字节指令,操作码为0xE8.在指令执行阶段,处理器看到操作码0xE8,就知道它应当调用一个过程.于是,它用指令指针寄存器IP的当前内容加上指令中的操作数,再加上3,得到一个新的偏移地址.接着将IP的原有内容压入栈.最后,用刚才的偏移地址取代IP原油的内容.这直接导致处理器的执行流程转移到目标位置处.第二种是16位间接绝对近调用,这种调用也是近调用,只能调用当前代码段内的过程,指令中的操作数不是偏移量,而是被调用过程的真实偏移地址,故称绝对地址.这个地址不是直接出现在指令中,而是由16位的通用寄存器或者16位的内存单元简介给出.第三种是16位直接绝对远调用,调用另一个代码段内的过程.比如:```shellcall0x20000:0x0030如果被调用过程处于当前代码段,也没关系.第四种是16位间接绝对远调用,这也属于段间调用,被调用过程属于另一个代码段.比如:callfar[0x2000]callfar[bx]间接远调用必须使用far.中断实模式下,处理器要求中断向量表需要存放在物理地址0x00000-&gt;0x003ff,同1k的空间内,共256个中断,每个中断向量4个字节.0x00000...-&gt;....0x003ff---------------------------------------------偏移地址(2字节)|段地址(2字节)|偏移地址..---------------------------------------------内联汇编常用约束r:Register(s)a:%eax,%ax,%alb:%ebx,%bx,%blc:%ecx,%cx,%cld:%edx,%dx,%dlS:%esi,%siD:%edi,%dii:直接操作数=:只写</li>
  <li>Probewebrtc使用gcc（googlecongestioncontrol）来估计带宽，控制当前的发送速度。gcc中基于丢包和基于延迟的算法有个特点：1.能迅速响应带宽的衰减2.不能迅速响应带宽的增加举个例子，如果当前带宽是20mbps，由于其它因素，带宽骤降至15mbps，gcc能快速的给出over-using信号(rtt为10ms环境下，响应速度是100-200ms)。如果当前带宽是20mbps，由于其它因素，带宽升至了25mbps，依赖gcc自身的调整的话需要几十秒的时间（加性增减性乘的效果）。由于以上的原因，如果从0bps开始运行gcc算法（纯算法本身），要达到一定的带宽需要太长的时间。webrtc中有一个用来在起始阶段（或周期性）迅速探测到当前带宽的措施—就是Probe模块，和TCP的慢启动比较像啦！原理Probe的原理简单说起来就是这样的：发送端以一定的速度发送数据包，同时记录这些数据包的发送时间、序列号（全局唯一）、探测组的id.接收端每过一段时间（50-150ms）会反馈数据包的到达时间，就像这样：s_t表示发送时间、r_t标识接受时间，这样我们就知道了发送速度、接收速度://发送端发送这些数据包的时间间隔common::TimeDeltasend_interval=common::TimeDelta(state.last_send-state.first_send);//接收端接收这些数据包的时间间隔common::TimeDeltarecive_interval=common::TimeDelta(state.last_recive-state.first_recive);//发送的字节数(已发送的字节减去最后一个数据包的字节，不难理解吧?)size_tsize_send=state.size_total_sent-state.size_last_sent;//接收端收到的字节数(已接收的字节减去第一个数据包的字节，不难理解吧?)size_tsize_recive=state.size_total_recived-state.size_first_recived;//从而就得到了双方的速度common::DataRatesend_bps=1_bps*(size_send*8/(send_interval/1_sec));common::DataRatereceive_bps=1_bps*(size_recive*8/(recive_interval/1_sec));我们定义S1为发送速度，R1为接收速度，那么可以认定当前的网络带宽至少是min(S1,R1)。在这里涉及到几个问题：如何控制发送端的速度探测包的大小如果设置才会比较合理探测应该持续多久，尽可能的避免对正常数据的影响控制探测速度、包大小、探测时长webrtc中探测包是通过一个定时器来控制速度的。假设我们需要探测的目标速度是10mbps，探测时间是10ms，那么我们总共需要发送的所有探测包的总大小total_bytes=10mbps*15ms/8;第一个探测包的大小取值为bytes1=10_mbps*1_ms/8，立即发送。为了控制速度，我们需要考虑第二个探测包的发送时间，假设是dt时间后发送，计算dt:dt=sent_bytes*8/1_mbps;意思就是已发送比特数除以目标码率，在dt的时间后发送第二个探测包，这样我们就精确地控制了发送速度就是我们希望的速度。以这种方式发送数据包，直到”已发送字节”大于等于total_bytes，该轮探测结束。上述中15ms就是探测需要持续的时间(可以自定义)，bytes1就是探测包的大小(通过修改”1_ms”可以自定义大小)通过一定的手段，我们可以将正常数据流上的数据包变为探测包，减少对正常数据流的影响。探测一般都是已当前速度的几倍去发送数据，所以必不可免的会影响当前的数据流，可以修改”15_ms”来自定义探测时长。乘性探测为了快速的探测到实际带宽的大致值，使用乘性探测。举个例子，假设起始速度设置为450kbps，那么探测速度就设置为900kbps，如果探测结果在900kbps*0.7=630kbps以上，继续向上探测，探测速度是1.8mbps，如果第二次探测结果在1.8mbps*0.7以上，继续向上探测，探测速度是3.6mbps…..直到某一个探测结果不符合“0.7以上”，那么就判定链路带宽应该在此次探测结果附近。然后，以这个速度发送数据流，在这个基础上运行gcc算法，通过延迟梯度和丢包来控制发送码率。实际情况在我的实现中。在rtt10ms的环境下，可以立刻探测到带宽上限。运行日志如下：probesuccessful,sendspeed:892.845kbps,receivespeed:898.797kbpsprobesuccessful,sendspeed:888.780kbps,receivespeed:891.707kbpsprobesuccessful,sendspeed:1.771mbps,receivespeed:1.628mbpsprobesuccessful,sendspeed:1.777mbps,receivespeed:2.214mbpsprobesuccessful,sendspeed:3.358mbps,receivespeed:3.337mbpsprobesuccessful,sendspeed:3.521mbps,receivespeed:3.591mbps...probesuccessful,sendspeed:30.376mbps,receivespeed:31.149mbpsprobesuccessful,sendspeed:59.897mbps,receivespeed:45.238mbps(达到带宽上限)则认为当前带宽的上限是45.238mbps(我通过tc命令设置的带宽就是45mbps，探测结果非常的准)从300kbps的起始速度上升到45mbps，用时800ms。在实际环境中，webrtc就是通过该机制在起始阶段迅速的”跳跃”到一个合适的码率上。解答meemetao@gmail.com</li>
  <li>template&lt;typenameT&gt;classshared_ptr{public:shared_ptr&lt;T&gt;(T*t){set_ptr(this,t);}};template&lt;typenameT&gt;classenable_shared_from_this{public:shared_ptr&lt;T&gt;shared_from_this(){//ifsp_notnullreturnsp_;}voidset_ptr(shared_ptr&lt;T&gt;p){sp_=p;}private:shared_ptr&lt;T&gt;sp_;//FIXME:weak_ptr};template&lt;typenameT&gt;voidset_ptr(shared_ptr&lt;T&gt;t,enable_shared_from_this&lt;T&gt;*e){e-&gt;set_ptr(t);}voidset_ptr(...){//donothing}classt:publicenable_shared_from_this&lt;t&gt;{public:t()=default;};当使用shared_ptr创建t对象时,t对象内部通过set_ptr将这个share_ptr对象包含在自己内部。但是这样子的话t永远无法析构自己，所以需要将内部的这个指针改为weak_ptr。</li>
  <li>延迟梯度左边的Tx表示发送时间，右边的tx表示接收时间。延迟梯度的计算公式就是：gt(i)=(t(i)-t(i-1))-(T(i)-T(i-1))，实际上就是发送间隔和接收间隔的差值。网络状态良好的情况下，这个值为0，当网络状态变差(发送端速度不变，接收端速度下降)，这个值为正。举个例子：发送端以1mbps的速度发送(每1ms发送1kb数据)，接收端的带宽仅有0.5mbsp，如下图:从第一个1kb到第二个1kb，发送端用时1ms，而接收端需要2ms，梯度=2-1=1ms。观测”延迟梯度”的值，就可以发现发送端和接收端的带宽不对等，需要改变一方的速度。考虑下面这一种情况：发送端与交换机之间的带宽是30mbps，接收端与交换机之间的带宽是10mbps。当发送端以10mbps的速度发送数据时，不考虑其它因素的影响，假设传播时延是10ms，那么任何数据包在10ms内就可以均匀到达接收端。当发送端以大于10mbps的速度发送数据时，由于接收端的网络设备的处理能力只有10mbps，会将无法及时转发的流量缓冲在出口队列中。模拟这下这种情况：发送端以10mbps的速度发送数据，维持100ms，提高速度到16mbps，维持150ms，下降速度到8mbps，并一直保持这个速度。假设发送端发送的单个报文长度为10kbit。前100ms内，接收端的带宽足够，不会有交换机缓冲。接下来的150ms，发送端速度大于接收端的带宽，有一半数据会被缓冲在交换机的队列中，队列长度不断增大，直至丢包。随后发送端速度下降到5mbps，队列中的数据又被不断抽出，直至恢复正常。用以下代码对上述情况进行简单的模拟:发送端std::vector&lt;Packet&gt;BitSender::send(common::Timestampat_time){usingnamespacecommon::rate;usingnamespacecommon::time_interval;//初始化if(!last_sent_time_.is_valid()){last_sent_time_=at_time;}size_tbits_will_send=0;std::vector&lt;Packet&gt;packets;bits_will_send=static_cast&lt;size_t&gt;(bps_.value()*((at_time-last_sent_time_)/1_sec));bits_sent_+=bits_will_send;size_tbits_reamin=bits_will_send;//向上取整longn=std::lround(bits_reamin*1.0/kPacketSize);for(inti=0;i&lt;n;i++){Packetpacket;packet.size=kPacketSize;packet.send_time=at_time;packets.push_back(packet);}last_sent_time_=at_time;returnpackets;}转发端//接受发送端的数据，放到队列中voidBitForwarder::recive(std::vector&lt;Packet&gt;&amp;packets){for(auto&amp;packet:packets){packet.delay=packet.delay+5_ms;//发送端-&gt;转发端传输时延fifo_.push(packet);}}//发送队列中的数据std::vector&lt;Packet&gt;BitForwarder::forward(common::Timestampat_time){size_tbits_will_forward=0;if(!last_forwarded_time_.is_valid()){last_forwarded_time_=at_time;}std::vector&lt;Packet&gt;forward_packets;bits_will_forward=static_cast&lt;size_t&gt;(bps_.value()*((at_time-last_forwarded_time_)/1_sec));bits_forwarded_+=bits_will_forward;size_tbits_remain=bits_will_forward;while(bits_remain&amp;&amp;fifo_.size()){if(fifo_.front().size&lt;=bits_remain){forward_packets.push_back(fifo_.front());bits_remain-=fifo_.front().size;fifo_.pop();}else{break;}}last_forwarded_time_=at_time;returnforward_packets;}接收端voidBitReciver::recive(std::vector&lt;Packet&gt;&amp;packets,common::Timestampat_time){for(auto&amp;packet:packets){packet.delay=packet.delay+5_ms;//转发端-&gt;接收端传输时延packet.recive_time=at_time;}record(packets);//对每个包的发送、接收时间进行记录}主函数intmain(){BitSendersender(0_mbps);BitReciverreciver(10_mbps);BitForwarderforwarder(reciver.bps());constautostart_time=common::Timestamp::now();constautokFirstStageEndTime=start_time+100_ms;constautokSecondStageEndTime=start_time+150_ms;constautokThirdStageEndTime=start_time+300_ms;constautokFirstStageBps=10_mbps;constautokSecondStageBps=16_mbps;constautokThirdStageBps=8_mbps;//粒度是5msautocur_time=start_time;sender.set_bps(kFirstStageBps);while(cur_time&lt;kFirstStageEndTime){autopackets=sender.send(cur_time);forwarder.recive(packets);autopackets_f=forwarder.forward(cur_time);reciver.recive(packets_f,cur_time);cur_time=cur_time+2_ms;//2ms处理间隔(尽量小,来模拟"时时刻刻"都在处理)}sender.set_bps(kSecondStageBps);while(cur_time&lt;kSecondStageEndTime){autopackets=sender.send(cur_time);forwarder.recive(packets);autopackets_f=forwarder.forward(cur_time);reciver.recive(packets_f,cur_time);cur_time=cur_time+2_ms;}sender.set_bps(kThirdStageBps);while(cur_time&lt;kThirdStageEndTime){autopackets=sender.send(cur_time);forwarder.recive(packets);autopackets_f=forwarder.forward(cur_time);reciver.recive(packets_f,cur_time);cur_time=cur_time+2_ms;}return0;}以时间t为横坐标，当前延迟梯度的累计和m(t)为纵坐标:变化方向对上图中的“曲线(实际情况中应该是曲线)”求切线:斜率&gt;0，转发设备中的缓冲队列在增大，如果继续保持这个速度，情况会不断恶化斜率&lt;0，转发设备中的缓冲队列在减小，如果继续保持这个速度，情况会不断改善线性回归TrendingLine模块的任务就是，根据历史的数据(时间和延迟梯度和)，计算当前一小段时间内的”斜率”，也就是”变化方向”，用于给速度控制模块参考信息。线性回归过程主要解决的就是如何通过样本来获取最佳的拟合线。最常用的方法便是最小二乘法，它是一种数学优化技术，它通过最小化误差的平方和寻找数据的最佳函数匹配。最小二乘法代码实现计算延迟梯度时，以5ms为间隔，对达到的数据进行分组(5ms内达到的数据为一组)，论文中是以一帧为间隔。webrtc中的代码不太好懂，我自己的实现(可能也不太好懂)：//对每一个到达的数据进行统计voidTrendingLineFilter::incoming_packet_feedback(int64_tsend_time,int64_trecive_time,size_tsize){(void)size;if(common::TimeDelta(send_time-cur_group_.first_packet_send_time)&gt;kSampleGroupInterval&amp;&amp;cur_group_.initialized()){//新的一组do{if(!prev_group_.initialized()){break;}//计算一组值assert(cur_group_.first_packet_send_time&gt;prev_group_.first_packet_send_time);assert(cur_group_.last_packet_recive_time&gt;prev_group_.last_packet_recive_time);int64_tsend_time_delta=cur_group_.first_packet_send_time-prev_group_.first_packet_send_time;int64_trecive_time_delta=cur_group_.last_packet_recive_time-prev_group_.last_packet_recive_time;int64_tdelta_us=recive_time_delta-send_time_delta;insert_new_sample_and_update(delta_us,recive_time);detect(send_time_delta,recive_time);//...}while(false);prev_group_=cur_group_;cur_group_=TimestampGroup();}if(cur_group_.first_packet_send_time&gt;0){cur_group_.first_packet_send_time=std::min(cur_group_.first_packet_send_time,send_time);}else{cur_group_.first_packet_send_time=send_time;}cur_group_.last_packet_recive_time=std::max(cur_group_.last_packet_recive_time,recive_time);}voidTrendingLineFilter::insert_new_sample_and_update(int64_tdelta_us,int64_tcomplete_time_us){constint64_tdelta_ms=std::lround(delta_us*1.0/1000);int64_tcomplete_time_ms=std::lround(complete_time_us*1.0/1000);first_arrive_time_ms_=std::min(first_arrive_time_ms_,complete_time_ms);acc_delay_+=delta_ms;num_delay_delta_++;num_delay_delta_=std::min&lt;int64_t&gt;(num_delay_delta_,1000);smoothed_delay_=smooth_coeff_*smoothed_delay_+(1-smooth_coeff_)*acc_delay_;sample_points_.push_back({//由于是"差"，所以每一组数据都不会非常大，数值不会溢出，可以放心用于后续的数学计算complete_time_ms-first_arrive_time_ms_,smoothed_delay_});if(sample_points_.size()&gt;=window_size_){/**@explain:*trend可以认为是对当前网络状态的一个反映:(send_rate-capacity)/capacity;*trend&gt;0,网络的排队延迟正在朝着增大的方向发展*trend&lt;0,网络的排队延迟正在朝..减少........*trend=0,没有变化*/cur_trend_=linear_regresion();sample_points_.pop_front();}}//根据数据公式进行计算doubleTrendingLineFilter::linear_regresion(){assert(sample_points_.size()==window_size_);doubletrend=cur_trend_;doublesum_x=0;doublesum_y=0;//TODO:在求平均数这个事情上可以有优化的措施//但是意义并不大for(constauto&amp;point:sample_points_){sum_x+=point.x;sum_y+=point.y;}doublex_avg=sum_x/sample_points_.size();doubley_avg=sum_y/sample_points_.size();doublenumerator=0;doubledenominator=0;for(constauto&amp;point:sample_points_){numerator+=(point.x-x_avg)*(point.y-y_avg);denominator+=(point.x-x_avg)*(point.x-x_avg);}//TODO:C++17的optional可以用在分母为0的处理if(denominator!=0){trend=numerator/denominator;}returntrend;}联系我meemetao@gmail.com</li>
  <li>前言此文算是一个notes，总结一下C++中的各类cast用法和原理。static_cast总结:反转一个定义良好的隐式类型转换static_cast执行关联类型之间的转换，比如一种指针类型向同一个类层次中其它指针类型的转换，或者整数类型向枚举类型的转换，或者浮点类型向整数类型的转换。它还能执行构造函数和转换运算符。同一类层次classB{};classD:publicB{}B和D就叫做同一个类层次。char*ptr_c=nullptr;int*ptr_i=static_cast&lt;int*&gt;(ptr_c);//编译失败B*ptr_b=newB();D*ptr_d=ptr_b;//编译失败D*ptr_d=static_cast&lt;D*&gt;(ptr_b);//fine但是，down_cast是没有任何保证的，程序员必须明白会发生什么事情。整数类型向枚举类型的转换enumclassE:uint8_t{kValue=1};uint8_tv=E::kValue;//编译失败uint8_tv=static_cast&lt;uint8_t&gt;(E::kValue);//fineconst_castconst_cast(expression)参与转换的类型仅在const修饰符及volatile修饰符上有所区别，除此以外new_type和expression的类型是一样。常量指针被转化成非常量的指针，并且仍然指向原来的对象。常量引用被转化成非常量的引用，并且仍然指向原来的对象。dynamic_castdynamic_cast&lt;type*&gt;(e)执行指针或者引用向类层次体系的类型转换，并执行运行时检查。不管是向上或者向下或者向左右都可以调用dynamic_cast。对于upcast，可以但没必要，向上塑性直接写就完事儿了。reinterpret_castreinterpret_cast(expression)这玩意就用的比较少了，和static_cast不一样，只有以下情况可以使用reinterpret_cast:1.表达式是整形、枚举、指针、或者成员指针2.指针和整形互转3.T1*可以和T2*互转4.T1左值可以转化为T2引用5.函数指针可以随便转，不用管类型。这里的函数指针包括类成员函数。相对与static_cast的区别，有以下一个例子:classA{public:intm_a;};classB{public:intm_b;};classC:publicA,publicB{};Cc;printf("%p,%p,%p",&amp;c,reinterpret_cast&lt;B*&gt;(&amp;c),static_cast&lt;B*&gt;(&amp;c));&gt;前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量，并将之转换到正确的地址（c里面有m_a,m_b，转换为B*指针后指到m_b处），而reinterpret_cast却不会做这一层转换。因此,你需要谨慎使用reinterpret_cast。static_pointer_castdynamic_pointer_castconst_pointer_castreinterpret_cast总结上述4个:template&lt;classT,classU&gt;std::shared_ptr&lt;T&gt;static_pointer_cast(conststd::shared_ptr&lt;U&gt;&amp;r)noexcept{autop=static_cast&lt;typenamestd::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());returnstd::shared_ptr&lt;T&gt;(r,p);}template&lt;classT,classU&gt;std::shared_ptr&lt;T&gt;dynamic_pointer_cast(conststd::shared_ptr&lt;U&gt;&amp;r)noexcept{if(autop=dynamic_cast&lt;typenamestd::shared_ptr&lt;T&gt;::element_type*&gt;(r.get())){returnstd::shared_ptr&lt;T&gt;(r,p);}else{returnstd::shared_ptr&lt;T&gt;();}}template&lt;classT,classU&gt;std::shared_ptr&lt;T&gt;const_pointer_cast(conststd::shared_ptr&lt;U&gt;&amp;r)noexcept{autop=const_cast&lt;typenamestd::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());returnstd::shared_ptr&lt;T&gt;(r,p);}template&lt;classT,classU&gt;std::shared_ptr&lt;T&gt;reinterpret_pointer_cast(conststd::shared_ptr&lt;U&gt;&amp;r)noexcept{autop=reinterpret_cast&lt;typenamestd::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());returnstd::shared_ptr&lt;T&gt;(r,p);}</li>
  <li>前言一直以来，字符串编码总是我摸不着头脑。对待字符串编码问题的策略也是简单粗暴，直接规避：一律使用utf-8。但是，猿在码界漂，哪能不挨刀。今天就总结一下字符串编码问题。编码类型介绍ascii编码格式花样很多。由于计算机是老美发明的，因此，最早只有127个字符被编码到计算机中，着127个字符被称为ascii编码集。由于ascii字符集只有127个字符，故只要一个字节就可以表示。else但是，世界上那么多国家、那么多语言，全世界人民都想体验一把先进文化，于是八仙过海，各显神通，日本把日文编码到Shift-jis中，韩国把韩文编码到Euc-kr中。我们国家陆续有gb2312、gbk、gb18030，后者都是对前者的扩展。拿我们汉字举例，汉字有成千上万个，所以一个字节表示不了那么多的汉字，所以就需要多个字节(2个或3个)来表示。unicode大家要是没有一套统一的编码格式的话，还怎么促进文化的交流、各国码农感情的培养。于是，unicode应运而生，unicode把所有语言都统一到一套编码中，这样大家就可以顺畅的交流了。为了表示那么多的语言，unicode也只能采用多字节表示法，就是一个字符用多个字节的数据表示。于是，新的问题又出现了。对于大部分西方国家，他们使用的英语，一个字节就可以表示一个字符。如果使用unicode，那岂不是很浪费空间。于是又有人想出来了一种更佳妙的方式：对unicode继续编码。（可以理解成对unicode压缩编码）也就说，utf-8,utf-16,utf-32是在unicode基础上，对unicode再次编码。以UTF-8来说：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：字符asciiunicodeutf-8A01000001000000000100000101000001中?0100111000101101111001001011100010101101这么多编码格式，大家的一个共同点就是：完全对ascii码兼容。也就是说ascii中的’a’，和gb2312中的’a’是同样的表示方法(假设是0x63)。实际环境Linux如果您是在linux上开发，通常是碰不到这些问题的。(没错，我就是舔狗)在Linux上，系统默认就是utf-8格式。这是什么意思？举例来说，当你“touchmain.cpp”这个文件就是采用的utf-8来编码里面的所有数据。当你intmain(){constchar*pstr="中文ABC";printf("%s\n",pstr);return0;}这个pstr中的内容就会以utf-8格式存储。当你:$g++main.cpp-oa.out&amp;./a.out编译器会忠于你的文件编码格式，按此编码格式处理该源文件。pstr中的内容会被取出来放在内存中，并以utf-8格式输出在终端环境上。终端能不能正常显示，就看你的终端能不能支持utf-8。任何的字符串乱码问题，就是上面这三种中的某一个或多个编码格式不一样导致。Windows在windows上，呵呵呵了。中文windows默认采用gb2312格式。举例来说。当你”新建一个文件”，这个文件通常是gb2312格式，如果这个文件只在本地使用，这时候通常是没问题的。但是当你因为某些原因需要使用在windows上使用”unicode”，问题就来了。还是以上面main.cpp为例：1.如果main.cpp为gb2312，用vs编译，pstr为gb2312格式，终端可以显示。2.如果main.cpp为纯unicode，用vs编译，pstr在内存里为gb2312格式，终端可以显示。3.如果main.cpp为utf-8(无bom)，用vs编译，pstr在内存里为utf-8格式，但是终端显示不了中文。4.如果main.cpp为utf-8(bom)，用vs编译，pstr在内存里为gb2312格式，终端可以显示。看到了吧，vs的”睿智”。这个问题如果搭配上”wchar_t”，更加让人恼火。上面的测试可以采用如下程序：voidfoo(unsignedchar*pstr,size_tsize){for(size_ti=0;i&lt;size;i++){printf("%x,",pstr[i]);}printf("\n");}intmain(){std::stringstr="abc中文ABC";char*pstr=const_cast&lt;char*&gt;(str.c_str());foo((unsignedchar*)pstr,sizeofstr);std::wstringwstr=L"abc中文ABC";wchar_t*pwstr=const_cast&lt;wchar_t*&gt;(wstr.c_str());foo((unsignedchar*)pwstr,sizeofstr);return0;}将结果和各个编码表进行对照，既可得出结论。在unicode方面，对windows的批评滔滔不绝，”utf-8everywhere”认为微软在字符串处理上误入歧途，因为他们比别的厂商更早做了决定。微软虽然有理由说，windows先于unicode问世。但是这么多年过去了，windows的API还是不完全支持unicode。windows不遵守基本法，也不是一天两天了，嘻嘻。关于如何在windows处理utf-8，以及对windwos的更多批评，可以从这篇文章起步:utf8everywhere“char与wchar_t，string与wstring如果您不幸遇到了string和wstring方便的困扰，恭喜您。首先，std::string和std::wstring都继承与std::basic_string。只不过std::string的模板参数是char，std::wstring的模板参数是wchar_t。在linux上，wchar_t占用4个字节，windows上则是占用2个字节。他们之间的差别，仅此而已。你如果使用wstring存放字符串，Linux是没有啥问题的，采用utf-32编码wstring。但是如果是windows上，嘻嘻，问题又来了。假设在main.cpp中存放了一个std::wstring=“abc中文”,那么：1.a.cpp如果是gb2312格式，wstring在内存中是unicode格式。2.a.cpp如果是unicode格式，wstring在内存中是unicode格式。3.a.cpp如果是utf-8格式，wstring在内存中是ucs-2be格式。4.a.cpp如果是utf-8-bom格式，wstring在内存中是unicode格式。您肯定还有一个疑惑，关于wstring和string之间的互相转换。那么，您需要确保你非常了解待转换的数据的格式，或者待转换数据仅来自本地。在windows上，windows有一个奇技淫巧：WideCharToMultiByte系列API，通过参数设定你就可以获得你所希望的结果。详见windowsapi说明，如何正确使用，请看：stackoverflow当然，c++标准库也可以做到：std::locale、std::codecvt结合使用。帮组文档utf8everywhere潜谈C/C++编程中的字符编码转换C++字符编码问题探究和中文乱码的产生获得帮助meemetao@gmail.com</li>
  <li>c++中的函数指针(假定在64位机器上)我们知道指针的大小恒定的,跟机器位数有关,32位机下,指针是4字节大小,64位机下指针是8字节大小.但是在C++中,有一个比较特殊的地方是C++的类成员函数指针,它的大小是普通指针的2倍.先看一个实例:voidfoo(void){}classA{public:voidfoo(){}}intmain(){void(*pfun)(void);pfun=foo;void(A::*pMfun)(void);pMfun=&amp;A::foo;std::cout&lt;&lt;"normalfunctionpointersize:"&lt;&lt;sizeof(pfun)&lt;&lt;std::endl;std::cout&lt;&lt;"memberfunctionpointersize:"&lt;&lt;sizeof(pMfun)&lt;&lt;std::endl;return0;}运行结果:normalfunctionpointersize:8memberfunctionpointersize:16证明完毕.下面解释为什么会这样.this指针的调整再看一个例子:classA{public;voidfoo(){//假设我们需要在这里去使用数组astd::cout&lt;&lt;"addrofthis:%x"&lt;&lt;this&lt;&lt;std::endl;}private:inta[4];};classB{public:voidbar(){//假设我们需要在这里去使用数组bstd::cout&lt;&lt;"addrofthis:%x"&lt;&lt;this&lt;&lt;std::endl;}prviate:intb[4];};classC:publicA,B{};intmain(){Cc;c.foo();c.bar();return0;}结果addrofthis:%x0x7ffd30f4ec00addrofthis:%x0x7ffd30f4ec10这时候可以看到,传递给foo和bar函数的this指针是不一样的?为什么会不一样呢?考虑一下函数中的注释.所以调用类成员函数指针时,就需要将this指针进行调整,这个调整的信息在哪里?就在这个函数指针中,所以就需要另外的空间去存放这些信息,这也就是为什么类成员函数指针是16字节的原因,因为多出来的8字节,用于编译期的this指针调整.</li>
  <li>安装与卸载apt-getinstallxxx#安装xxxapt-getremovexxx#卸载xxxapt-getupdate#更新软件信息数据库apt-getupgrade#进行系统升级apt-cachesearch#搜索软件包文件查找find/-namefilename替换操作语法为:[addr]s/源字符串/目的字符串/[option][addr]//表示检索范围，省略时表示当前行。//如:"1，20":表示从第1行到20行；"%"://表示整个文件，同“1,$”；".,$"://从当前行到文件尾；s://表示替换操作[option]://表示操作类型//如:g表示全局替换;//c表示进行确认//p表示替代结果逐行显示（Ctrl+L恢复屏幕）；//省略option时仅对每行第一个匹配串进行替换；//如果在源字符串和目的字符串中出现特殊字符，需要用”\”转义压缩、解压tar-c:建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出下面的参数-f是必须的-f:使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。tar-cfall.tar*.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。tar-rfall.tar*.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。tar-ufall.tarlogo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。tar-tfall.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思tar-xfall.tar这条命令是解出all.tar包中所有文件，-t是解开的意思压缩tar-cvfjpg.tar*.jpg//将目录里所有jpg文件打包成tar.jpgtar-czfjpg.tar.gz*.jpg//将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar-cjfjpg.tar.bz2*.jpg//将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar-cZfjpg.tar.Z*.jpg//将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrarajpg.rar*.jpg//rar格式的压缩，需要先下载rarforlinuxzipjpg.zip*.jpg//zip格式的压缩，需要先下载zipforlinux解压tar-xvffile.tar//解压tar包tar-xzvffile.tar.gz//解压tar.gztar-xjvffile.tar.bz2//解压tar.bz2tar-xZvffile.tar.Z//解压tar.Zunrarefile.rar//解压rarunzipfile.zip//解压zip解压jdk到指定文件夹：tar-xzvfjdk-8u131-linux-x64.tar.gz-C/usr/local/java统计代码行数1.find./-name*.cppxargswc-l2.find./-name*.cpp|xargswc-l|sort-n常用shell环境变量添加1.echoexportPATH=$(pwd):$PATH进制xx服务开机启动:update-rcdisablexx</li>
  <li>前几天做通信原理的实验，发现网上关于维特比算法的解释太理论化，我结合代码通俗话的解释一下。如果看了以下代码您还是不能理解维特比纠错算法的真实目的，请务必联系我！首先，我问大家一个问题，如下：A，B，C代表三个地点，三条实线代表路径。假设张三现在要去A、B、C的其中一个地方，由于淘宝上买了一个劣质的指南针，方向出了偏差，虚线是他走过的路，我们不知道到底偏了多少。我们以上帝视觉猜测张三的目的，显然：看上去张三的目的地好像是B。如果我们信赖这个指南针(偏的并不离谱),那么我们的结论也许就是对的。注意哦,我们的结论是根据最近的地点距离猜得，并不是非常准确，也就是说张三的目的地是A也是有可能的，即:指南针偏的的太多了这里的”偏的太多了”，在通信上可以认为信息在传输过程受到了非常大的干扰，导致接收到的信息已经面目全非，想要恢复原有信息的话已经不太可能。这就是维特比算法的一部分,根据汉明距离来选择最有可能通往下一个节点的路径。所以说，如果信息位错的太离谱了，它就不可靠了，这个不离谱是有一个度的，具体是多少，您可以参考下面的代码做个实验。对了！如果您不知道什么是汉明距离，那么您可以直接关掉这个页面了。好了，接下来我们来模拟一下整个信息传输过程,我默认您已经掌握了一定的原理，知道什么是M序列、卷积码等。第一步：产生M序列function[mseq]=m_sequence(fbconnection,register)n=length(fbconnection);N=2^n-1;mseq(1)=register(n);%m序列的第一个输出码元fori=2:Nnewregister(1)=mod(sum(fbconnection.*register),2);forj=2:nnewregister(j)=register(j-1);end;register=newregister;mseq(i)=register(n);end其中fbconnection就是我们要发送的信息，它被认为是M序列的特征方程的阶次。我们把它定义成函数，将这个文件命名为:createMsequence.m,在matlab中，输入：vector=createMsequence(…,…)就可以产生一个信息段对应的M序列。示列：mes=[1001];%我们要发送的信息,我这里假设是4位，当然不论多少位都是可以的init=[1,zeros(1,length(mes)-1)];%寄存器初始值mseq=createMsequence(mes,init);%调用之前我们写的代码运行实例:加密、卷积我们先随机产生一个和M序列等长度的01码，我们把这个序列认为是密码子，也就是说接收方如果想要结算它接收到的信息，必须依靠这个密码子。加密secret=randint(1,length(mseq));加密函数就简单点，直接异或吧。mseq=bitxor(mseq,secret);我们现在再来看一下差异。卷积然后我们再对这个序列进行卷积,我采用的是最简单的3,1,3卷积:function[out]=conv(vector);len=length(vector);b1=vector(1);b2=0;b3=0;fori=1:lenc1=b1;c2=xor(b1,b3);c3=xor(xor(b1,b2),b3);out(3*(i-1)+1)=c1;out(3*(i-1)+2)=c2;out(3*(i-1)+3)=c3;b3=b2;b2=b1;if(i&lt;len)b1=vector(i+1);endend这是3,1,3卷积编码的实现，具体的实现框图我相信您肯定知道的，不难的，不就是一个迭代么。信道传输我们知道信号的传输过程受环境影响很大，有干扰的情况下很容易造成信息位错乱，其实就是抽样判决的时候导致的。假设信号序列在传输过程中出错了，导致了某些位由原来的1-&gt;0,0-&gt;1，我们就令第3、4位吧。convolution(3)=~convolution(3);convolution(4)=~convolution(4);第四步：接收、差错纠正recevive=convolution;decode_out=decode(recevive);嘿嘿，全文的重点来了，维特比解码算法这里我就直接贴代码了，相信我，如果您专心取理解每一行代码，肯定是看得懂的！维特比算法的原理呢，如果您看不懂，结合下面的代码来看会有事半功倍的效果！%MemeTao2017.4.16%维特比算法仅支持(3,1,3)卷积码%PS:请在调用前保证序列长度&gt;=3*3为什么?这不是常识么？！function[out]=receive(vector)len=length(vector);%获取输入序列长度if(mod(len,3)&gt;0)disp('fuckyou!');%序列长度肯定是3的倍数，因为313卷积码嘛!end%下面我要开始初始化route了%如果您看不懂下面的路径初始化,%不用怀疑,绝对是没理解卷积码的逆向推导,请去看书%abcd是状态%aaabbc...是路径a=[00];b=[01];c=[10];d=[11];aa=[000];ab=[111];bc=[001];bd=[110];ca=[011];cb=[100];dc=[010];dd=[101];%你还是看不懂？那怎么办？下面更看不懂咯！^_^^_^%按照理论,每一次仅存在8条路径，然后判决出4条幸存路径%管他呢route=cell(1,8);route_survive=cell(1,4);status=cell(1,8);dis_cur=zeros(1,8);dis_survive=zeros(1,8);%--------------------------------8条路径+4条幸存-----------------------------------%route{1}=[aa,aa,aa];status{1}=a;dis_cur(1)=hanmingDis(route{1},vector(1:9));route{2}=[ab,bc,ca];status{2}=a;dis_cur(2)=hanmingDis(route{2},vector(1:9));route{3}=[aa,aa,ab];status{3}=b;dis_cur(3)=hanmingDis(route{3},vector(1:9));route{4}=[ab,bc,cb];status{4}=b;dis_cur(4)=hanmingDis(route{4},vector(1:9));route{5}=[aa,ab,bc];status{5}=c;dis_cur(5)=hanmingDis(route{5},vector(1:9));route{6}=[ab,bd,dc];status{6}=c;dis_cur(6)=hanmingDis(route{6},vector(1:9));route{7}=[aa,ab,bd];status{7}=d;dis_cur(7)=hanmingDis(route{7},vector(1:9));route{8}=[ab,bd,dd];status{8}=d;dis_cur(8)=hanmingDis(route{8},vector(1:9));fori=1:4if(dis_cur(2*i-1)&lt;=dis_cur(2*i))route_survive{i}=route{2*i-1};dis_survive(i)=dis_cur(2*i-1);elseroute_survive{i}=route{2*i};dis_survive(i)=dis_cur(2*i);endendforindex=10:3:len%重新产生八条路径%casea状态A,下同route{1}=[route_survive{1},aa];%增加一条a-a路径dis_cur(1)=dis_survive(1)+hanmingDis(aa,vector(index:index+2));%更新汉明距离route{3}=[route_survive{1},ab];%增加一条a-b路径dis_cur(3)=dis_survive(1)+hanmingDis(ab,vector(index:index+2));%更新汉明距离%caseb:route{5}=[route_survive{2},bc];%增加一条b-c路径dis_cur(5)=dis_survive(2)+hanmingDis(bc,vector(index:index+2));%更新汉明距离route{7}=[route_survive{2},bd];%增加一条b-d路径dis_cur(7)=dis_survive(2)+hanmingDis(bd,vector(index:index+2));%casec:route{2}=[route_survive{3},ca];%增加一条c-a路径dis_cur(2)=dis_survive(3)+hanmingDis(ca,vector(index:index+2));%更新汉明距离route{4}=[route_survive{3},cb];%增加一条c-b路径dis_cur(4)=dis_survive(3)+hanmingDis(cb,vector(index:index+2));%更新汉明距离%cased:route{6}=[route_survive{4},dc];%增加一条d-c路径dis_cur(6)=dis_survive(4)+hanmingDis(dc,vector(index:index+2));%更新汉明距离route{8}=[route_survive{4},dd];%增加一条d-d路径dis_cur(8)=dis_survive(4)+hanmingDis(dd,vector(index:index+2));%更新汉明距离%重新产生幸存序列fori=1:4if(dis_cur(2*i-1)&lt;=dis_cur(2*i))route_survive{i}=route{2*i-1};dis_survive(i)=dis_cur(2*i-1);elseroute_survive{i}=route{2*i};dis_survive(i)=dis_cur(2*i);endendend%答案就在最后的幸存序列里面min=realmax();%最大整数fori=1:4if(dis_survive(i)&lt;min)min=dis_survive(i);tar=i;endendconvolution=route_survive{tar};%现在找到噪声之前的卷积码了！%下面进行的是卷积码逆向推回M序列，即我们最终的答案mse=zeros(1,3);forindex_con=1:3:length(convolution)mse=convolution(index_con:index_con+2);if(all(mse(:)==aa(:))||all(mse(:)==bc(:))||all(mse(:)==ca(:))||all(mse(:)==dc(:)))out(round(index_con/3)+1)=0;elseout(round(index_con/3)+1)=1;endend%简直佩服我自己！哈哈哈！关于汉明距离的计算我认为这个您是可以自己接触的，出于人道主义：functionhanmingDis=input(src,cur)len_src=length(src);len_cur=length(cur);if(len_src~=len_cur)disp('errorinput:len_curnotequallen_src');enddis=0;fori=1:len_curif(cur(i)~=src(i))dis=dis+1;endendhanmingDis=dis;好，我们来测试一下在出现差错的情况下，它是否还能还原信息序列：总结与测试截至到这里，我们已经完成的工作是：产生M序列-&gt;加密-&gt;卷积编码-&gt;模拟信道传输-&gt;维特比纠错解码-&gt;还原M序列-&gt;还原最初的信息</li>
</ul>