<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome my site</title>
    <description>中国计量大学本科 通信工程 在读(2017)
 
</description>
    <link>http://MemeTao.github.io//</link>
    <atom:link href="http://MemeTao.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 14 Jan 2019 19:01:13 +0800</pubDate>
    <lastBuildDate>Mon, 14 Jan 2019 19:01:13 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>2019一月学习计划</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;1-计算机体系结构&quot;&gt;1. 计算机体系结构&lt;/h3&gt;
&lt;p&gt;晚上7.00-晚上8.30&lt;/p&gt;
&lt;h3 id=&quot;2-操作系统学习&quot;&gt;2. 操作系统学习&lt;/h3&gt;
&lt;p&gt;晚上9.00-晚上10.30&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//studyplay_january/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//studyplay_january/</guid>
        
        
        <category>study</category>
        
        <category>plan</category>
        
      </item>
    
      <item>
        <title>操作系统加载全过程</title>
        <description>&lt;hr /&gt;

&lt;p&gt;这将是一个漫长的过程，终将解答我心中的疑惑….&lt;/p&gt;

&lt;h3 id=&quot;step-1-存储设备的第521字节&quot;&gt;step 1: 存储设备的第521字节&lt;/h3&gt;
&lt;p&gt;Boot sector(引导扇区)是所有存储介质上的第一个扇区，大小为512字节。主要分为三个部分，分别是:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;MBR(master boot record,主引导记录) 445字节&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;DPT(disk partition table,磁盘分区表) 64字节&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;BRID(boot record ID 引导记录标示) 2字节
        &lt;h4 id=&quot;mbr&quot;&gt;MBR&lt;/h4&gt;
        &lt;p&gt;主引导记录的作用是安装基本的引导加载程序(boot loader),在Linux中是grub。grub的主要功能是：&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;提供菜单：用户可以选择不同的开机选项，这是多重引导的虫咬功能。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;载入内核文件: 直接指向可开机的程序区段来开始操作系统&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;转交其它Loader: 将引导加载功能交给其它loader处理&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 11 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//os_study/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//os_study/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>ubuntu18.04上安装英伟达驱动</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;1查看显卡设备&quot;&gt;1.查看显卡设备&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#lspci &lt;/span&gt;
00:02.0 VGA compatible controller: Intel Corporation HD Graphics 620 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rev 02&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
302:00.0 3D controller: NVIDIA Corporation GM108M &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GeForce 940MX]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;一个是集成显卡,一个是独立显卡。点击”设置”-”详细信息”可以看到当前所使用的是哪一个显卡。&lt;/p&gt;

&lt;p&gt;查看推荐的显卡驱动&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# sudo ubuntu-drivers devices&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; /sys/devices/pci0000:00/0000:00:1c.0/0000:02:00.0 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;
modalias : pci:v000010DEd0000134Dsv000017AAsd00002246bc03sc02i00
vendor   : NVIDIA Corporation
model    : GM108M &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GeForce 940MX]
driver   : nvidia-driver-390 - distro non-free recommended
driver   : xserver-xorg-video-nouveau - distro free &lt;span class=&quot;nb&quot;&gt;builtin&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#sudo add-apt-repository ppa:graphics-drivers&lt;/span&gt;
Current long-lived branch release: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nvidia-410&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;410.66&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Old long-lived branch release: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nvidia-390&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;390.87&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;不知道为啥，找不到410&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#sudo apt update&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2安装&quot;&gt;2.安装&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;#sudo apt-get install nvidia-390   //安装390驱动&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#重启&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#重启完就ojbk了&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 09 Jan 2019 12:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//InstallNvidiaDriver/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//InstallNvidiaDriver/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>字符串编码</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;一直以来，字符串编码总是我摸不着头脑。对待字符串编码问题的策略也是简单粗暴，直接规避：一律使用utf-8。但是，猿在码界漂，哪能不挨刀。今天就总结一下字符串编码问题。&lt;/p&gt;
&lt;h3 id=&quot;编码类型介绍&quot;&gt;编码类型介绍&lt;/h3&gt;
&lt;h4 id=&quot;ascii&quot;&gt;ascii&lt;/h4&gt;
&lt;p&gt;编码格式花样很多。由于计算机是老美发明的，因此，最早只有127个字符被编码到计算机中，着127个字符被称为ascii编码集。由于ascii字符集只有127个字符，故只要一个字节就可以表示。&lt;/p&gt;

&lt;h4 id=&quot;else&quot;&gt;else&lt;/h4&gt;
&lt;p&gt;但是，世界上那么多国家、那么多语言，全世界人民都想体验一把先进文化，于是八仙过海，各显神通，日本把日文编码到Shift-jis中，韩国把韩文编码到Euc-kr中。我们国家陆续有gb2312、gbk、gb18030，后者都是对前者的扩展。拿我们汉字举例，汉字有成千上万个，所以一个字节表示不了那么多的汉字，所以就需要多个字节(2个或3个)来表示。&lt;/p&gt;
&lt;h4 id=&quot;unicode&quot;&gt;unicode&lt;/h4&gt;
&lt;p&gt;大家要是没有一套统一的编码格式的话，还怎么促进文化的交流、各国码农感情的培养。于是，unicode应运而生，unicode把所有语言都统一到一套编码中，这样大家就可以顺畅的交流了。为了表示那么多的语言，unicode也只能采用多字节表示法，就是一个字符用多个字节的数据表示。&lt;/p&gt;

&lt;p&gt;于是，新的问题又出现了。对于大部分西方国家，他们使用的英语，一个字节就可以表示一个字符。如果使用unicode，那岂不是很浪费空间。于是又有人想出来了一种更佳妙的方式：对unicode继续编码。（可以理解成对unicode压缩编码）&lt;/p&gt;

&lt;p&gt;也就说，utf-8,utf-16,utf-32是在unicode基础上，对unicode再次编码。&lt;/p&gt;

&lt;p&gt;以UTF-8来说：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ascii&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;unicode&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;00000000 01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01001110 00101101  11100100 10111000&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10101101&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这么多编码格式，大家的一个共同点就是：完全对ascii码兼容。也就是说ascii中的’a’，和gb2312中的’a’是同样的表示方法(假设是0x63)。&lt;/p&gt;

&lt;h3 id=&quot;实际环境&quot;&gt;实际环境&lt;/h3&gt;
&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;如果您是在linux上开发，通常是碰不到这些问题的。(没错，我就是舔狗)&lt;/p&gt;

&lt;p&gt;在Linux上，系统默认就是utf-8格式。这是什么意思？&lt;/p&gt;

&lt;p&gt;举例来说，当你 “touch main.cpp” 这个文件就是采用的utf-8来编码里面的所有数据。
当你&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个pstr中的内容就会以utf-8格式存储。
当你:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;g++ main.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; a.out
&amp;amp; ./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;编译器会忠于你的文件编码格式，按此编码格式处理该源文件。pstr中的内容会被取出来放在内存中，并以utf-8格式输出在终端环境上。终端能不能正常显示，就看你的终端能不能支持utf-8。&lt;/p&gt;

&lt;p&gt;任何的字符串乱码问题，就是上面这三种中的某一个或多个编码格式不一样导致。&lt;/p&gt;
&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;在windows上，呵呵呵了。中文windows默认采用gb2312格式。&lt;/p&gt;

&lt;p&gt;举例来说。当你”新建一个文件”，这个文件通常是gb2312格式，如果这个文件只在本地使用，这时候通常是没问题的。&lt;/p&gt;

&lt;p&gt;但是当你因为某些原因需要使用在windows上使用”unicode”，问题就来了。
还是以上面main.cpp为例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.如果main.cpp为gb2312，用vs编译，pstr为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;2.如果main.cpp为纯unicode，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;3.如果main.cpp为utf-8(无bom)，用vs编译，pstr在内存里为utf-8格式，但是终端显示不了中文。&lt;/li&gt;
  &lt;li&gt;4.如果main.cpp为utf-8(bom)，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到了吧，vs的”睿智”。这个问题如果搭配上”wchar_t”，更加让人恼火。&lt;/p&gt;

&lt;p&gt;上面的测试可以采用如下程序：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%x,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将结果和各个编码表进行对照，既可得出结论。&lt;/p&gt;

&lt;p&gt;在unicode方面，对windows的批评滔滔不绝，”utf-8 everywhere”认为微软在字符串处理上误入歧途，因为他们比别的厂商更早做了决定。微软虽然有理由说，windows先于unicode问世。但是这么多年过去了，windows的API还是不完全支持unicode。&lt;/p&gt;

&lt;p&gt;windows不遵守基本法，也不是一天两天了，嘻嘻。&lt;/p&gt;

&lt;p&gt;关于如何在windows处理utf-8，以及对windwos的更多批评，可以从这篇文章起步: &lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt; “&lt;/p&gt;
&lt;h3 id=&quot;char与wchar_tstring与wstring&quot;&gt;char与wchar_t，string与wstring&lt;/h3&gt;
&lt;p&gt;如果您不幸遇到了string和wstring方便的困扰，恭喜您。&lt;/p&gt;

&lt;p&gt;首先，std::string 和 std::wstring都继承与std::basic_string。
只不过std::string的模板参数是char，std::wstring的模板参数是wchar_t。
在linux上，wchar_t占用4个字节，windows上则是占用2个字节。他们之间的差别，&lt;strong&gt;仅此而已。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你如果使用wstring存放字符串，Linux是没有啥问题的，采用utf-32编码wstring。&lt;/p&gt;

&lt;p&gt;但是如果是windows上，嘻嘻，问题又来了。假设在main.cpp中存放了一个std::wstring = “abc中文”,那么：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.a.cpp如果是gb2312格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;2.a.cpp如果是unicode格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;3.a.cpp如果是utf-8格式，wstring在内存中是ucs-2be格式。&lt;/li&gt;
  &lt;li&gt;4.a.cpp如果是utf-8-bom格式，wstring在内存中是unicode格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;您肯定还有一个疑惑，&lt;strong&gt;关于wstring和string之间的互相转换&lt;/strong&gt;。
那么，您需要确保你非常了解待转换的数据的格式，或者待转换数据仅来自本地。&lt;/p&gt;

&lt;p&gt;在windows上，windows有一个奇技淫巧：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WideCharToMultiByte系列API，通过参数设定你就可以获得你所希望的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见windows api说明，如何正确使用，请看： &lt;a href=&quot;https://stackoverflow.com/questions/215963/how-do-you-properly-use-widechartomultibyte&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，c++标准库也可以做到：std::locale、std::codecvt结合使用。&lt;/p&gt;

&lt;h3 id=&quot;帮组文档&quot;&gt;帮组文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/59522148&quot;&gt;潜谈C/C++编程中的字符编码转换&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/ybusad/blog/363139&quot;&gt;C++字符编码问题探究和中文乱码的产生&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;获得帮助&quot;&gt;获得帮助&lt;/h3&gt;
&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Nov 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//string-coding/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//string-coding/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>C++成员函数指针的大小</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;c中的函数指针假定在64位机器上&quot;&gt;c++中的函数指针(假定在64位机器上)&lt;/h3&gt;

&lt;p&gt;我们知道指针的大小恒定的,跟机器位数有关,32位机下,指针是4字节大小,64位机下指针是8字节大小.但是在C++中,有一个比较特殊的地方是C++的类成员函数
指针,它的大小是普通指针的2倍.先看一个实例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void foo(void)
{
}
class A{
public:
    void foo(){}
}

int main()
{
    void (*pfun)(void);
    pfun = foo;
    void (A::*pMfun)(void);
    pMfun = &amp;amp;A::foo;
    std::cout&amp;lt;&amp;lt;&quot;normal function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pfun)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&quot;member function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pMfun)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;normal &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:8
member &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;证明完毕.下面解释为什么会这样.&lt;/p&gt;
&lt;h3 id=&quot;this指针的调整&quot;&gt;this指针的调整&lt;/h3&gt;

&lt;p&gt;再看一个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class A{
public;
    void foo()
    {
        //假设我们需要在这里去使用数组a
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
private:
    int a[4];
};
class B{
public:
    void bar()
    { 
        //假设我们需要在这里去使用数组b
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
prviate:
    int b[4];
};
class C: public A,B{

};

int main()
{
    C c; 
    c.foo();
    c.bar();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addr of this:%x0x7ffd30f4ec00
addr of this:%x0x7ffd30f4ec10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候可以看到,传递给foo和bar函数的this指针是不一样的?为什么会不一样呢? 考虑一下函数中的注释.
所以调用类成员函数指针时,就需要将this指针进行调整,这个调整的信息在哪里?就在这个函数指针中,所以就需要另外的空间去存放这些信息,这也就是为什么类成员函数指针是16字节的原因,因为多出来的8字节,用于编译期的this指针调整.&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Jul 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>Socket注意事项:非阻塞connect的返回值</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;问题引入&quot;&gt;问题引入：&lt;/h3&gt;
&lt;p&gt;为了测试1S内TCP服务器单线程能accept多少并发TCP连接，由于正常的TCP建立可能需要几十毫秒，所以客户端发起的连接应该是这样子的:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_NONBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//非阻塞connect
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;代码运行后，我发现connect()返回值一直是false，但是使用tcpdump抓包发现tcp三次握手正常，也就是说仅仅是connect函数的返回值不符合预期。&lt;/p&gt;

&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;我再一次翻开«UNP»，在书上发现：&lt;strong&gt;当在一个非阻塞的TCP套接字上调用connect时，将立即返回一个EINPROGRESS错误，不过已经发起的TCP三路握手继续进行&lt;/strong&gt;，
这样问题就清晰了，修改代码如下：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_NONBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//非阻塞connect
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EINPROGRESS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注:errno是线程安全的，每个线程都保留一份errno。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;纸上得来终觉浅，绝知此事需躬行&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Feb 2018 15:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//SocketConnect/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//SocketConnect/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>TCP四次挥手中，Poll返回了几次？</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;我在给多线程TCP服务器写被动关闭逻辑时遇到了一个疑问，Poll返回的时机是什么时候？TCP四次挥手能够引起几次Poll返回？&lt;/p&gt;
&lt;h3 id=&quot;如何引入的问题&quot;&gt;如何引入的问题&lt;/h3&gt;
&lt;p&gt;一般的服务器编程逻辑，一般是由客户端发起的主动关闭，服务端实行被动关闭。按正常的流程是这样的:对端发送FIN，服务端发送ACK，如果没有多余数据，随即再发送FIN分节，对端继续发送ACK便进入熟知的TIME_WAIT状态，等待2MSL时间后进入CLOSE状态，本次TCP连接顺利断开。依照这个模型，我们只要在fd上注册一个回调函数，等poll返回时，用read系统调用即可判断是正常数据还是FIN分节，很容易得到如下回调函数伪代码:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//对端发来信息
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//正常处理信息
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//说明对端发送了FIN分节
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;addTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//让其它空闲线程来处理这个连接的资源
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//发送FIN
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上述代码在实际的运行时，发生了错误，操作系统提示我一个关键词：&lt;strong&gt;double free&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;寻找症结&quot;&gt;寻找症结&lt;/h3&gt;

&lt;p&gt;根据提示:我猜测是某些资源释放了多次。在多次复现问题后，最终发现这个问题出现在TCP连接断开的时候。&lt;/p&gt;

&lt;p&gt;我用Linux下的NC工具模拟了客户端TCP连接，并用tcpdump试图分析出一点蛛丝马迹：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./TcpServer &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; 65500     //在本地65500端口启动服务器
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nc 127.0.0.1 65500       //连接到服务器65500端口
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;Ctrl-D                   //一段时间后，NC主动断开连接 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以下是tcpdump本地抓包结果：
&lt;img src=&quot;../material/POLL/tcpdump.png&quot; alt=&quot;TCPDUMP&quot; /&gt;
首先是TCP三次握手，随后等我键入Ctrl-D断开连接，TCP四次挥手也很正常(由于FIN分节携带了ACK，所以表现出来是3个报文),然后服务端依然奔溃，并提示double free!&lt;/p&gt;

&lt;p&gt;用netstat命令显示的TCP状态变化:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;protocol&lt;/th&gt;
      &lt;th&gt;port1&lt;/th&gt;
      &lt;th&gt;port2&lt;/th&gt;
      &lt;th&gt;status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp&lt;/td&gt;
      &lt;td&gt;—65500—&lt;/td&gt;
      &lt;td&gt;—59580—&lt;/td&gt;
      &lt;td&gt;—–ESTABLISHED&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp&lt;/td&gt;
      &lt;td&gt;—59580—&lt;/td&gt;
      &lt;td&gt;—65500—&lt;/td&gt;
      &lt;td&gt;—–TIME_WAIT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明连接是正常建立，正常断开的，一切都很正常!看来是一场硬仗，得调试代码了，由于当前还没有加入日志模块，用gdb又好像有点小题大作，先用printf大法试一下再说，最终发现&lt;strong&gt;在TCP四次挥手中，read() = 0 返回了两次！&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;引起poll返回的事件&quot;&gt;引起poll返回的事件&lt;/h3&gt;

&lt;p&gt;根据我的代码结构，回调之前是poll，随即开始查资料，在《APUE》中发现，以下条件是引起poll返回的特定revent:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;有数据可读，专业的说法是：套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低潮限度的当前值。可以使用套接字选项SO_RCVLOWAT来设置低潮限度，对于TCP和UDP套接字，其值缺省为1&lt;/li&gt;
  &lt;li&gt;连接的读这一半关闭，也就是说接收了FIN的TCP连接。对这样的套接字的套接字将不阻塞且返回0（即文件结束符）&lt;/li&gt;
  &lt;li&gt;套接字是一个监听套接字且已完成的连接数为非0，即连接建立后可读&lt;/li&gt;
  &lt;li&gt;有一个套接字错误待处理。对这样的套接字的读操作将不阻塞且返回一个错误（-1），errno则设置成明确的错误条件。这些待处理的错误也可以通过指定套接口选项SO_ERROR调用getsockopt来取得并清除。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;«UNP»还有如下补充:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;所有TCP和UDP正规数据都被认为是普通数据&lt;/li&gt;
  &lt;li&gt;TCP的待外数据被认为是优先级带数据&lt;/li&gt;
  &lt;li&gt;当TCP连接的读半部关闭时(譬如收到一个对端的FIN)，也被认为是普通数据，随后的读操作将返回0&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;那客户端进入TIME_WAIT状态时发送的最后一次ACK是不是一次普通数据呢?&lt;/strong&gt;在这个情况下，没有其它什么事件能够引起poll返回了，很明显了，罪魁祸首就是&lt;strong&gt;TCP四次挥手的第四次ACK！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题的关键以及解决方案&quot;&gt;问题的关键以及解决方案&lt;/h3&gt;
&lt;p&gt;之所以会出现这样的问题，是由于我的代码执行顺序的问题，由于是多线程，一个线程close(fd)使得tcp发送FIN分节，理论上，再此之前我们就应该注销掉这个连接的资源了。而我的代码试图将资源释放这个问题推迟一些以便于处理当下更紧急的其它任务，所以在poll所关注的事件列表中还有这个连接所关注的事件，所以引起了这个问题。清楚了原因之后，立马找到了解决方案：我只要注销掉poll中的该事件对应的fd即可，依然可以使得资源释放稍后执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方案一：具体是在read()返回0，后随机注销掉该socket_fd的一切事件。伪代码描述如下:
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//如果不懂,请查阅struct pollfd
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;addTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//让其他线程来处理该连接的资源
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;方案二:一个TCP连接的所以资源自始自终都由某一个线程管理，不要转移fd。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我修改了代码，两种方案都可以达到预期目标，考虑代码结构的问题，我采用了方案二。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;解决了上述问题后，我反思自己:当初看APUE和UNP的时候对上述问题之所以没有留下深刻的印象，原因恐怕是没有实际情况作为参照。想起一句名句:&lt;strong&gt;纸上得来终觉浅，绝知此事需躬行&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Feb 2018 15:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//Poll/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//Poll/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>TCP:多线程同时accept到底有没有必要?</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;一问题&quot;&gt;一、问题&lt;/h3&gt;
&lt;p&gt;最近在写一个TCP多线程服务器，模型是这样的：1个线程接受TCP新连接，从线程池中挑出一个EventLoop线程给这个TCP连接，以后这个TCP连接的所有操作都将由这个EventLoop线程负责。我疑惑的点是：&lt;strong&gt;仅由一个线程accept新连接，够么？能够处理多少并发量？&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;二分析问题&quot;&gt;二、分析问题&lt;/h3&gt;
&lt;p&gt;已经知道的知识是，TCP有个半连接队列和已连接队列(等待应用层accept)，如下：
&lt;img src=&quot;../material/ThunderingHerd/TCP connection.png&quot; alt=&quot;TcpConnectionProcess&quot; /&gt;
(图片来源:https://segmentfault.com/a/1190000008224853)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SYNC队列:长度为 max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)，在我的机器上，后者的值是:128&lt;/li&gt;
  &lt;li&gt;ACCEPT队列:长度为 min(backlog, somaxconn)，/proc/sys/net/core/somaxconn的值为128，表示最多有129的ESTABLISHED的连接等待accept()，而backlog的值则应该是由int listen(int sockfd, int backlog)中的第二个参数指定，listen里面的backlog可以有我们的应用程序去定义的。
    &lt;h4 id=&quot;21当sync队列满了&quot;&gt;2.1当sync队列满了&lt;/h4&gt;
    &lt;p&gt;当这个队列满了，不开启syncookies的时候，Server会丢弃新来的SYN包，而Client端在多次重发SYN包得不到响应而返回（connection time out）错误。但是，当Server端开启了syncookies=1，那么SYN半连接队列就没有逻辑上的最大值了，并且/proc/sys/net/ipv4/tcp_max_syn_backlog设置的值也会被忽略。&lt;/p&gt;
    &lt;h4 id=&quot;22当accept队列满了&quot;&gt;2.2当accept队列满了&lt;/h4&gt;
    &lt;p&gt;当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过/proc/sys/net/ipv4/tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。&lt;/p&gt;
    &lt;h4 id=&quot;23如何查看是否存在队列溢出&quot;&gt;2.3如何查看是否存在队列溢出&lt;/h4&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;listen|LISTEN&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;由于我电脑不是服务器，没有溢出的情况，暂时不能举例。&lt;/p&gt;
    &lt;h4 id=&quot;24如果客户端第三个ack已达到但是服务端没有accept且客户端发送了信息这时发生什么&quot;&gt;2.4如果客户端第三个ACK已达到，但是服务端没有accept，且客户端发送了信息，这时发生什么?&lt;/h4&gt;
    &lt;p&gt;我没有做相应的实验，查资料得知，服务端不做任何响应，客户端超时重传，直至断开连接。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;三单线程accept的极限参数&quot;&gt;三、单线程accept的极限参数&lt;/h3&gt;
&lt;p&gt;现在我们可以得到的结论是，高并发下，上述的队列参数的确会限制TCP并发连接数。可是具体参数是多少呢？我暂时不得而知，但我不久便会做个相应的实验(认真脸)!&lt;/p&gt;

&lt;p&gt;今天做了测试，模型是这样的: &lt;strong&gt;一个线程专门poll监听描述符号，有新连接就accept，然后将新fd交给其它线程，继续poll+accept&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;测试记录&quot;&gt;测试记录&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;电脑参数&lt;/strong&gt;：双核+i5+4G 普通家用电脑&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;发起连接数&lt;/strong&gt;:50个进程，每个进程发起200个TCP连接，总共10K个连接，目标是 127.0.0.1:65500，发起连接后不管有无成功等待10S后，退出进程。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;服务端&lt;/strong&gt;:监听65500端口，来一个接收一个。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;现象&lt;/strong&gt;:服务端syn和accept队列被挤满，”netstat -s ]  grep listen”发现大量overflowed, ，1S内接收的TCP连接，最大时达到1200。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;:有时服务端会残留少量已连接TCP ，netstat ] grep localhost*.65500 可看到该问题 。可是客户端都已经关闭了，按理说每个连接都发送FIN分节。更加有意思的是，若在发起几波TCP连接，这些残留TCP会自动被服务端注销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;对测试结果的总结与思考&quot;&gt;对测试结果的总结与思考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;关于残留TCP连接，我怀疑是Localhost的原因，由于数据量真的有点大了，我没有很好的办法追踪这个问题，只能暂时留个坑了。好在，结果是正确的，影响很小。&lt;/li&gt;
  &lt;li&gt;将poll换成epoll，如果仅仅是对于提高“接收TCP新连接”性能来说可能帮助并不大，因为要监听的端口号仅1个。&lt;/li&gt;
  &lt;li&gt;测试结果和电脑硬件有一定关系，但是数量级肯定是K级别，由于本地瞬间出现了大量的临时进程(50个发起10000TCP连接的进程），大量占用了CPU时间，所以实际上的结果肯定是偏小的。&lt;/li&gt;
  &lt;li&gt;因为是localhost，不经过数据链路层、网络层，有一定影响，但不大(猜测）&lt;/li&gt;
  &lt;li&gt;由于连接的断开也是该线程负责，但是每个客户端都预留了10S维持该连接，所以，poll+accept 循环间隔已经很短了。所以，测试的结果和可信。&lt;/li&gt;
  &lt;li&gt;如果以后有机会，换台高配主机，远程发起连接，再测试一回(认真脸)
    &lt;h3 id=&quot;四有没有必要&quot;&gt;四、有没有必要？&lt;/h3&gt;
    &lt;p&gt;好了，现在继续。有了单线程accept的数据，我做大胆的分析：&lt;strong&gt;如果是为了提高TCP新连接并发数，多线程accept是可以的。&lt;/strong&gt;
假设我们的目标是使得单机承受100W个并发连接，并假设服务端成功的接收了上述的100W客户。&lt;/p&gt;
    &lt;h4 id=&quot;41我们先计算几个参数&quot;&gt;4.1我们先计算几个参数&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;服务端1s内给所有客户发送一个hello,world!报文占用的带宽:&lt;/li&gt;
  &lt;li&gt;上述连接占用的内存&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;42内核是否能承受&quot;&gt;4.2内核是否能承受？&lt;/h4&gt;

&lt;h3 id=&quot;五结论&quot;&gt;五、结论&lt;/h3&gt;
&lt;p&gt;未完待续~&lt;del&gt;2018-1-29
我暂时还是无法得出结论，但是主流网络库都是1个线程进行accept。我还会继续在这个问题上学习，网络上关于这个问题的讨论，真知灼见貌似寥寥无几。未完待续&lt;/del&gt;~2018-2-10&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 15:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//ThunderingHerdProblem/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//ThunderingHerdProblem/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>TCP缓冲区与write系统调用</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;
&lt;p&gt;在非阻塞多线程TCP网络编程中，设想一个场景:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;程序A想通过TCP连接发送100KB的数据,我们通过系统调用write()来写入数据。因为我不希望程序长时间阻塞在write()，我希望操作系统迅速将我的100KB数据放入TCP缓冲区，然后write()系统调用返回，内核自动将我们的100KB数据通过TCP发送出去。这里不经有个疑问:TCP缓冲区可以放下我的100KB数据么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上的&lt;em&gt;TCP缓冲区&lt;/em&gt;我故意描述的比较有歧义，网上很多关于TCP缓冲区大小的资料都有一定的误导。首先查阅Linux man手册：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SO_SNDBUF—————-
          Sets or gets the maximum socket send buffer in bytes.  The
          kernel doubles this value (to allow space for bookkeeping
          overhead) when it is set using setsockopt(2), and this doubled
          value is returned by getsockopt(2).  The default value is set
          by the /proc/sys/net/core/wmem_default file and the maximum
          allowed value is set by the /proc/sys/net/core/wmem_max file.
          The minimum (doubled) value for this option is 2048.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我随即查看我的电脑上的配置&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;运行结果：&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wmem_default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;套接字缓冲区大小&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;写&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;212992&lt;/span&gt; 
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_wmem&lt;/span&gt;   
&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;	&lt;span class=&quot;mi&quot;&gt;16384&lt;/span&gt;	&lt;span class=&quot;mi&quot;&gt;4194304&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了确认这些数据，我在自己电脑上用以下程序做了实验:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//#include some head file
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optlen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPPROTO_TCP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getsockopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOL_SOCKET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SO_SNDBUF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;error&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;val:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结果是16384。&lt;/p&gt;

&lt;p&gt;为什么我程序输出的却是/pro/sys/ipv4/tcp_wmen的默认值呢？我迷惑了，难道是Linux man 手册说错了?&lt;/p&gt;

&lt;p&gt;这是网上相当多博客最大的误解，有人将其看作是TCP缓冲区大小，有人将其看作是TCP发送窗口大小。&lt;/p&gt;

&lt;p&gt;后来我在IBM的文档中找到了这么一行:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;/proc/sys/net/ipv4/tcp_wmem	 4096 16384 131072	
—–为自动调优定义每个 socket 使用的内存。第一个值是为 socket 的发送缓冲区分配的最少字节数。第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我彻底明白了，每当我们新建一个socket，Linux内核认为大多数时候我们并不会用到如此之大的socket缓冲区，为了内存方面的考虑，所以用16384 = 16KB作为优化值。当我们的数据大于16KB时，是会自动往上增加的，一直到/pro/sys/net/wmem_default,也就是212992 = 208KB。
看到这里，有人会有疑问，也是我在网上搜索资料时遇到的误解:&lt;strong&gt;滑动窗口最大才2^16 = 65536 = 64KB，你这208KB怎么还比64KB大了？&lt;/strong&gt;
为此我又重新翻阅了一下«TCP/IP VO.1»&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;就 window scaling 来说，TCP 最初可以支持最大为 64KB 的窗口（使用 16 位的值来定义窗口的大小）。采用 window scaling（RFC 1323）扩展之后，您就可以使用 32 位的值来表示窗口的大小了。GNU/Linux 中提供的 TCP/IP 栈可以支持这个选项（以及其他一些选项）。提示：Linux 内核还包括了自动对这些 socket 缓冲区进行优化的能力（请参阅下面 表 1 中的 tcp_rmem 和 tcp_wmem），不过这些选项会对整个栈造成影响。如果您只需要为一个连接或一类连接调节窗口的大小，那么这种机制也许不能满足您的需要了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么我的电脑上有没有这所谓的window scaling呢？&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;运行结果：&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_window_scaling&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;有的。依稀记得好像有这么一句化：当前的以太网带宽发展很快，以前的双绞线10MB以太网现在已经发展到千兆以太网，所以16位的窗口值在一些场合已经不适用了。&lt;/p&gt;

&lt;h5 id=&quot;用一个例子来理解一下上面所说的概念socket缓冲区大小&quot;&gt;用一个例子来理解一下上面所说的概念:socket缓冲区大小&lt;/h5&gt;
&lt;p&gt;举个小例子：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;当我们建立一个socket的时候，内核自动给我分配的是16KB的缓存区,假设程序有100KB数据，我们调用write(fd,data)将数据写入的是套接字缓冲区，由于100KB &amp;gt; 16KB ，缓冲区自动增大，由于100 &amp;lt; 208 故，操作系统将数据从用户态拷到内核缓存区后，write系统调用就返回了，然后TCP从该缓冲区中取数据，TCP得搬运好多次，但是这都是内核的事情，我们管不着。如果数据是209KB，很显然，write()调用势必要阻塞了，阻塞到什么时候?我的理解是,阻塞到TCP将多余的1KB发送出去，并收到回复。(例子可能不是很恰当,如果有不明确的自己google吧)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这下我放心了，100KB是可以放下的。但是我不免有点后怕，我并不确定我的程序到底会有多大的数据,如果下次我们数据是250KB怎么办？我并不想程序阻塞在这里，我得尽快抽身去忙活其它紧急的事情，那该怎么办呢？往下看。&lt;/p&gt;

&lt;h3 id=&quot;如何解决write调用阻塞的问题&quot;&gt;如何解决write调用阻塞的问题？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.&lt;strong&gt;将accept返回的已连接TCP套接字设置成non-blocking&lt;/strong&gt; —— 比方我要写100KB，假设内核只接收了64KB,这时候,write写了64KB之后会返回,程序不会阻塞在这里，而是继续运行。那么又会引入另一个问题,&lt;strong&gt;剩余的36KB数据怎么办？&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;2.&lt;strong&gt;在程序中引入应用层缓冲区&lt;/strong&gt;——对于应用程序来说,我只管产生数据,并调用sendMessage()函数,你最终要分几次发送我不管,但是你不能阻塞我。具体做法是,封装sendMessage()函数:
    &lt;blockquote&gt;
      &lt;p&gt;判断write函数的返回值,将剩余的数据丢给Buffer,注册POLLOUT事件,等到对应的fd可读时，再将数据写入。这时候还有&lt;em&gt;第二点好处&lt;/em&gt;,当buffer有多余数据时，我们可以判断出socket缓冲区已经满了，我们不要调用write(),而是应该将数据添加到buffer中统一写入，这样做好处是什么：&lt;strong&gt;省了一次系统调用,岂不是美滋滋!&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何确定要多大的socket缓冲区是不是越大越好&quot;&gt;如何确定要多大的socket缓冲区，是不是越大越好？&lt;/h3&gt;

&lt;p&gt;IBM是这么说的,&lt;em&gt;&lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSQPD3_2.6.0/com.ibm.wllm.doc/UDPSocketBuffers.html&quot;&gt;click heare link to IBM!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;On the Linux platform Tx ring buffer overruns can occur when transmission rates approach 1Gbps and the default send socket buffer is greater than 65536. It is therefore recommended to set the net.core.wmem_default kernel parameter to 65536 bytes on all Linux systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就说在千兆以太网上，为了避免产生TX环形缓冲区溢出，我们最好将core/net/wmem_default设置成小于65536,也即64KB的一个值。但是这可是占内存的，如果我们给每一个socket都设置64KB，不考虑虚拟内存,假设机器内存是4GB，4GB / 64 KB = 16K，也即理论上在4G机器上，我们最多连接16K个TCP连接，这当然是不能接收的。所以这个问题要用毛泽东思想来解决：具体问题具体分析！&lt;/p&gt;

&lt;h3 id=&quot;如何确定应用层buffer的大小&quot;&gt;如何确定应用层Buffer的大小？&lt;/h3&gt;

&lt;p&gt;同样，这也是占内存的,我们不能过大也不能过少，这看起来好像也无解。&lt;/p&gt;

&lt;p&gt;这里推荐一个&lt;strong&gt;&lt;a href=&quot;https://github.com/chenshuo/muduo&quot;&gt;Muduo网络库&lt;/a&gt;&lt;/strong&gt;的做法:动态增长。具体做法是，给每个Buffer初始分配1024B字节，并在栈上分配一个65536字节的数组。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读取：使用readv,buffer作为第一个地址，数组作为第二个地址，这样超过1024的数据全都读到了数组上，等读取结束在将buffer扩增，将数组内的数据追加到buffer。&lt;/li&gt;
  &lt;li&gt;写入：比较简单，判断一下长度即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做利用了临时栈上空间，避免每个连接的初始Buffer过大造成内存浪费，也避免反复调用read()的系统开销。&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 15:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//TcpBuffer/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//TcpBuffer/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>linux操作记录</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;安装与卸载&quot;&gt;安装与卸载&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;apt-get install xxx #安装xxx&lt;/li&gt;
  &lt;li&gt;apt-get remove xxx  #卸载xxx&lt;/li&gt;
  &lt;li&gt;apt-get update      #更新软件信息数据库&lt;/li&gt;
  &lt;li&gt;apt-get upgrade     #进行系统升级&lt;/li&gt;
  &lt;li&gt;apt-cache search    #搜索软件包
    &lt;h3 id=&quot;文件查找&quot;&gt;文件查找&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;find / -name filename
        &lt;h3 id=&quot;替换操作&quot;&gt;替换操作&lt;/h3&gt;
        &lt;h4 id=&quot;语法为-addrs源字符串目的字符串option&quot;&gt;语法为 :[addr]s/源字符串/目的字符串/[option]&lt;/h4&gt;
        &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//表示检索范围，省略时表示当前行。
//如:&quot;1，20&quot;:表示从第1行到20行；
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//表示整个文件，同“1,$”；
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.,$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//从当前行到文件尾；
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;s:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//表示替换操作
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//表示操作类型
//如: g 表示全局替换; 
//c 表示进行确认
//p 表示替代结果逐行显示（Ctrl + L恢复屏幕）；
//省略option时仅对每行第一个匹配串进行替换；
//如果在源字符串和目的字符串中出现特殊字符，需要用”\”转义
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;h3 id=&quot;统计代码行数&quot;&gt;统计代码行数&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;1.find ./ -name *.cpp&lt;/td&gt;
          &lt;td&gt;xargs wc -l&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;2.find ./ -name *.cpp | xargs wc -l | sort -n
    &lt;h3 id=&quot;常用shell&quot;&gt;常用shell&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;环境变量添加 1.echo export PATH=$(pwd):$PATH&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 12 Apr 2017 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//linuxOperation/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//linuxOperation/</guid>
        
        
        <category>linux</category>
        
      </item>
    
  </channel>
</rss>
