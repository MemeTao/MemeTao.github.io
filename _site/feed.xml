<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome my site</title>
    <description>中国计量大学本科 通信工程 在读(2017)
 
</description>
    <link>http://MemeTao.github.io//</link>
    <atom:link href="http://MemeTao.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 09 Feb 2019 16:51:27 +0800</pubDate>
    <lastBuildDate>Sat, 09 Feb 2019 16:51:27 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>X86进入保护模式前的准备</title>
        <description>&lt;hr /&gt;

</description>
        <pubDate>Sat, 09 Feb 2019 16:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//x86_protection_mode/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//x86_protection_mode/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>c函数调用栈</title>
        <description>&lt;hr /&gt;

</description>
        <pubDate>Sat, 09 Feb 2019 14:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//function_statck/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//function_statck/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>一种在网络中时间同步的方式(精度100us)</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;本文介绍在&lt;strong&gt;非异常恶劣&lt;/strong&gt;的网络中，如何同步两台机器的本地时间，我们的目标是&lt;strong&gt;尽量(大概率上)&lt;/strong&gt;将时间同步的误差控制在0.1ms。&lt;/p&gt;

&lt;p&gt;众所周知，网络中存在time服务器，利用ntp协议可以将网络中主机的本地时间同步到1s的误差范围。对于正常应用，这个精度应该是够的。但是总存在一些
特殊应用，它对时间的精度要求更高。在这种情况下，time服务已经不满足我们的需要了。&lt;/p&gt;

&lt;h3 id=&quot;基本方式&quot;&gt;基本方式&lt;/h3&gt;
&lt;p&gt;在ping模式下，机器A发送一个包，并记录发包时间t1，机器B收到Icmp包后发送ack包，机器A收到ack包后记录收包时间t2，t2减t1就被认为是rtt。&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Jan 2019 11:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//timesynchronize/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//timesynchronize/</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>2019一月学习计划</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;1-计算机体系结构&quot;&gt;1. 计算机体系结构&lt;/h3&gt;
&lt;p&gt;晚上7.00-晚上8.30&lt;/p&gt;
&lt;h3 id=&quot;2-操作系统学习&quot;&gt;2. 操作系统学习&lt;/h3&gt;
&lt;p&gt;晚上9.00-晚上10.30&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//studyplay_january/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//studyplay_january/</guid>
        
        
        <category>study</category>
        
        <category>plan</category>
        
      </item>
    
      <item>
        <title>AT&amp;T汇编</title>
        <description>&lt;h3 id=&quot;1-intel-x86_64寄存器介绍&quot;&gt;1. intel x86_64寄存器介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通用寄存器&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;共有16个通用寄存器，如下图所示:
&lt;img src=&quot;../material/X86_64ASSEMBLY/general_register.png&quot; alt=&quot;generalRegister&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Segment Register&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;CS:存放程序在内存中的基地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;DS:数据段地址(.data?)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;«Linux 0.11完全注释»P90有关于这个的介绍&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指令指针寄存器(EIP)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;远跳转:在分段模式下，当跳转到另一个段中的指令时&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;短跳转:当跳转偏移量小于128字节时&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;近跳转:除12外的所有其它跳转
&lt;strong&gt;堆栈指针寄存器(ESP)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;0.指向栈顶&lt;/li&gt;
  &lt;li&gt;1.函数调用:通常和EBP一起配合使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-函数&quot;&gt;2. 函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;声明函数&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pushl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;movl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#code from here
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;movl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;popl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;堆栈情况:
&lt;img src=&quot;../material/X86_64ASSEMBLY/stack_overview.png&quot; alt=&quot;stackOverview&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2链接器&quot;&gt;2.链接器&lt;/h3&gt;
&lt;p&gt;一段程序包含.text .data .bss 段链接器会将所有的目标文件的这些段合并在一块。
&lt;img src=&quot;../material/X86_64ASSEMBLY/link_object.png&quot; alt=&quot;ldOverview&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-内存寻址&quot;&gt;3. 内存寻址&lt;/h3&gt;
&lt;p&gt;虚拟地址：[16][32] 16位段选择符、32位偏移地址&lt;/p&gt;

&lt;p&gt;所有段可以有14^2个，段内偏移可以达到4G&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/X86_64ASSEMBLY/memeory_addressing.png&quot; alt=&quot;memory_addressing&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//att_assembly_manaul/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//att_assembly_manaul/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>操作系统加载全过程</title>
        <description>&lt;hr /&gt;

&lt;p&gt;这将是一个漫长的过程，终将解答我心中的疑惑….&lt;/p&gt;
&lt;h3 id=&quot;step-0汇编&quot;&gt;step 0:汇编&lt;/h3&gt;

&lt;h3 id=&quot;step-1-存储设备的第512字节&quot;&gt;step 1: 存储设备的第512字节&lt;/h3&gt;
&lt;p&gt;Boot sector(引导扇区)是所有存储介质上的第一个扇区，大小为512字节。主要分为三个部分，分别是:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;MBR(master boot record,主引导记录) 445字节&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;DPT(disk partition table,磁盘分区表) 64字节&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;BRID(boot record ID 引导记录标示) 2字节
        &lt;h4 id=&quot;mbr&quot;&gt;MBR&lt;/h4&gt;
        &lt;p&gt;主引导记录的作用是安装基本的引导加载程序(boot loader),在Linux中是grub。grub的主要功能是：&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;提供菜单：用户可以选择不同的开机选项，这是多重引导的虫咬功能。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;载入内核文件: 直接指向可开机的程序区段来开始操作系统&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;转交其它Loader: 将引导加载功能交给其它loader处理&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//os_study/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//os_study/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>ubuntu18.04上安装英伟达驱动</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;1查看显卡设备&quot;&gt;1.查看显卡设备&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#lspci &lt;/span&gt;
00:02.0 VGA compatible controller: Intel Corporation HD Graphics 620 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rev 02&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
302:00.0 3D controller: NVIDIA Corporation GM108M &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GeForce 940MX]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;一个是集成显卡,一个是独立显卡。点击”设置”-”详细信息”可以看到当前所使用的是哪一个显卡。&lt;/p&gt;

&lt;p&gt;查看推荐的显卡驱动&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# sudo ubuntu-drivers devices&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; /sys/devices/pci0000:00/0000:00:1c.0/0000:02:00.0 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;
modalias : pci:v000010DEd0000134Dsv000017AAsd00002246bc03sc02i00
vendor   : NVIDIA Corporation
model    : GM108M &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GeForce 940MX]
driver   : nvidia-driver-390 - distro non-free recommended
driver   : xserver-xorg-video-nouveau - distro free &lt;span class=&quot;nb&quot;&gt;builtin&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#sudo add-apt-repository ppa:graphics-drivers&lt;/span&gt;
Current long-lived branch release: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nvidia-410&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;410.66&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Old long-lived branch release: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nvidia-390&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;390.87&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;不知道为啥，找不到410&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#sudo apt update&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2安装&quot;&gt;2.安装&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;#sudo apt-get install nvidia-390   //安装390驱动&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#重启&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#重启完就ojbk了&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 09 Jan 2019 12:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//InstallNvidiaDriver/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//InstallNvidiaDriver/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>字符串编码</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;一直以来，字符串编码总是我摸不着头脑。对待字符串编码问题的策略也是简单粗暴，直接规避：一律使用utf-8。但是，猿在码界漂，哪能不挨刀。今天就总结一下字符串编码问题。&lt;/p&gt;
&lt;h3 id=&quot;编码类型介绍&quot;&gt;编码类型介绍&lt;/h3&gt;
&lt;h4 id=&quot;ascii&quot;&gt;ascii&lt;/h4&gt;
&lt;p&gt;编码格式花样很多。由于计算机是老美发明的，因此，最早只有127个字符被编码到计算机中，着127个字符被称为ascii编码集。由于ascii字符集只有127个字符，故只要一个字节就可以表示。&lt;/p&gt;

&lt;h4 id=&quot;else&quot;&gt;else&lt;/h4&gt;
&lt;p&gt;但是，世界上那么多国家、那么多语言，全世界人民都想体验一把先进文化，于是八仙过海，各显神通，日本把日文编码到Shift-jis中，韩国把韩文编码到Euc-kr中。我们国家陆续有gb2312、gbk、gb18030，后者都是对前者的扩展。拿我们汉字举例，汉字有成千上万个，所以一个字节表示不了那么多的汉字，所以就需要多个字节(2个或3个)来表示。&lt;/p&gt;
&lt;h4 id=&quot;unicode&quot;&gt;unicode&lt;/h4&gt;
&lt;p&gt;大家要是没有一套统一的编码格式的话，还怎么促进文化的交流、各国码农感情的培养。于是，unicode应运而生，unicode把所有语言都统一到一套编码中，这样大家就可以顺畅的交流了。为了表示那么多的语言，unicode也只能采用多字节表示法，就是一个字符用多个字节的数据表示。&lt;/p&gt;

&lt;p&gt;于是，新的问题又出现了。对于大部分西方国家，他们使用的英语，一个字节就可以表示一个字符。如果使用unicode，那岂不是很浪费空间。于是又有人想出来了一种更佳妙的方式：对unicode继续编码。（可以理解成对unicode压缩编码）&lt;/p&gt;

&lt;p&gt;也就说，utf-8,utf-16,utf-32是在unicode基础上，对unicode再次编码。&lt;/p&gt;

&lt;p&gt;以UTF-8来说：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ascii&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;unicode&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;00000000 01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01001110 00101101  11100100 10111000&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10101101&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这么多编码格式，大家的一个共同点就是：完全对ascii码兼容。也就是说ascii中的’a’，和gb2312中的’a’是同样的表示方法(假设是0x63)。&lt;/p&gt;

&lt;h3 id=&quot;实际环境&quot;&gt;实际环境&lt;/h3&gt;
&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;如果您是在linux上开发，通常是碰不到这些问题的。(没错，我就是舔狗)&lt;/p&gt;

&lt;p&gt;在Linux上，系统默认就是utf-8格式。这是什么意思？&lt;/p&gt;

&lt;p&gt;举例来说，当你 “touch main.cpp” 这个文件就是采用的utf-8来编码里面的所有数据。
当你&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个pstr中的内容就会以utf-8格式存储。
当你:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;g++ main.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; a.out
&amp;amp; ./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;编译器会忠于你的文件编码格式，按此编码格式处理该源文件。pstr中的内容会被取出来放在内存中，并以utf-8格式输出在终端环境上。终端能不能正常显示，就看你的终端能不能支持utf-8。&lt;/p&gt;

&lt;p&gt;任何的字符串乱码问题，就是上面这三种中的某一个或多个编码格式不一样导致。&lt;/p&gt;
&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;在windows上，呵呵呵了。中文windows默认采用gb2312格式。&lt;/p&gt;

&lt;p&gt;举例来说。当你”新建一个文件”，这个文件通常是gb2312格式，如果这个文件只在本地使用，这时候通常是没问题的。&lt;/p&gt;

&lt;p&gt;但是当你因为某些原因需要使用在windows上使用”unicode”，问题就来了。
还是以上面main.cpp为例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.如果main.cpp为gb2312，用vs编译，pstr为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;2.如果main.cpp为纯unicode，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;3.如果main.cpp为utf-8(无bom)，用vs编译，pstr在内存里为utf-8格式，但是终端显示不了中文。&lt;/li&gt;
  &lt;li&gt;4.如果main.cpp为utf-8(bom)，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到了吧，vs的”睿智”。这个问题如果搭配上”wchar_t”，更加让人恼火。&lt;/p&gt;

&lt;p&gt;上面的测试可以采用如下程序：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%x,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将结果和各个编码表进行对照，既可得出结论。&lt;/p&gt;

&lt;p&gt;在unicode方面，对windows的批评滔滔不绝，”utf-8 everywhere”认为微软在字符串处理上误入歧途，因为他们比别的厂商更早做了决定。微软虽然有理由说，windows先于unicode问世。但是这么多年过去了，windows的API还是不完全支持unicode。&lt;/p&gt;

&lt;p&gt;windows不遵守基本法，也不是一天两天了，嘻嘻。&lt;/p&gt;

&lt;p&gt;关于如何在windows处理utf-8，以及对windwos的更多批评，可以从这篇文章起步: &lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt; “&lt;/p&gt;
&lt;h3 id=&quot;char与wchar_tstring与wstring&quot;&gt;char与wchar_t，string与wstring&lt;/h3&gt;
&lt;p&gt;如果您不幸遇到了string和wstring方便的困扰，恭喜您。&lt;/p&gt;

&lt;p&gt;首先，std::string 和 std::wstring都继承与std::basic_string。
只不过std::string的模板参数是char，std::wstring的模板参数是wchar_t。
在linux上，wchar_t占用4个字节，windows上则是占用2个字节。他们之间的差别，&lt;strong&gt;仅此而已。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你如果使用wstring存放字符串，Linux是没有啥问题的，采用utf-32编码wstring。&lt;/p&gt;

&lt;p&gt;但是如果是windows上，嘻嘻，问题又来了。假设在main.cpp中存放了一个std::wstring = “abc中文”,那么：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.a.cpp如果是gb2312格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;2.a.cpp如果是unicode格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;3.a.cpp如果是utf-8格式，wstring在内存中是ucs-2be格式。&lt;/li&gt;
  &lt;li&gt;4.a.cpp如果是utf-8-bom格式，wstring在内存中是unicode格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;您肯定还有一个疑惑，&lt;strong&gt;关于wstring和string之间的互相转换&lt;/strong&gt;。
那么，您需要确保你非常了解待转换的数据的格式，或者待转换数据仅来自本地。&lt;/p&gt;

&lt;p&gt;在windows上，windows有一个奇技淫巧：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WideCharToMultiByte系列API，通过参数设定你就可以获得你所希望的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见windows api说明，如何正确使用，请看： &lt;a href=&quot;https://stackoverflow.com/questions/215963/how-do-you-properly-use-widechartomultibyte&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，c++标准库也可以做到：std::locale、std::codecvt结合使用。&lt;/p&gt;

&lt;h3 id=&quot;帮组文档&quot;&gt;帮组文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/59522148&quot;&gt;潜谈C/C++编程中的字符编码转换&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/ybusad/blog/363139&quot;&gt;C++字符编码问题探究和中文乱码的产生&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;获得帮助&quot;&gt;获得帮助&lt;/h3&gt;
&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Nov 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//string-coding/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//string-coding/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>C++成员函数指针的大小</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;c中的函数指针假定在64位机器上&quot;&gt;c++中的函数指针(假定在64位机器上)&lt;/h3&gt;

&lt;p&gt;我们知道指针的大小恒定的,跟机器位数有关,32位机下,指针是4字节大小,64位机下指针是8字节大小.但是在C++中,有一个比较特殊的地方是C++的类成员函数
指针,它的大小是普通指针的2倍.先看一个实例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void foo(void)
{
}
class A{
public:
    void foo(){}
}

int main()
{
    void (*pfun)(void);
    pfun = foo;
    void (A::*pMfun)(void);
    pMfun = &amp;amp;A::foo;
    std::cout&amp;lt;&amp;lt;&quot;normal function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pfun)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&quot;member function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pMfun)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;normal &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:8
member &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;证明完毕.下面解释为什么会这样.&lt;/p&gt;
&lt;h3 id=&quot;this指针的调整&quot;&gt;this指针的调整&lt;/h3&gt;

&lt;p&gt;再看一个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class A{
public;
    void foo()
    {
        //假设我们需要在这里去使用数组a
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
private:
    int a[4];
};
class B{
public:
    void bar()
    { 
        //假设我们需要在这里去使用数组b
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
prviate:
    int b[4];
};
class C: public A,B{

};

int main()
{
    C c; 
    c.foo();
    c.bar();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addr of this:%x0x7ffd30f4ec00
addr of this:%x0x7ffd30f4ec10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候可以看到,传递给foo和bar函数的this指针是不一样的?为什么会不一样呢? 考虑一下函数中的注释.
所以调用类成员函数指针时,就需要将this指针进行调整,这个调整的信息在哪里?就在这个函数指针中,所以就需要另外的空间去存放这些信息,这也就是为什么类成员函数指针是16字节的原因,因为多出来的8字节,用于编译期的this指针调整.&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Jul 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>Socket注意事项:非阻塞connect的返回值</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;问题引入&quot;&gt;问题引入：&lt;/h3&gt;
&lt;p&gt;为了测试1S内TCP服务器单线程能accept多少并发TCP连接，由于正常的TCP建立可能需要几十毫秒，所以客户端发起的连接应该是这样子的:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_NONBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//非阻塞connect
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;代码运行后，我发现connect()返回值一直是false，但是使用tcpdump抓包发现tcp三次握手正常，也就是说仅仅是connect函数的返回值不符合预期。&lt;/p&gt;

&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;我再一次翻开«UNP»，在书上发现：&lt;strong&gt;当在一个非阻塞的TCP套接字上调用connect时，将立即返回一个EINPROGRESS错误，不过已经发起的TCP三路握手继续进行&lt;/strong&gt;，
这样问题就清晰了，修改代码如下：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_NONBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//非阻塞connect
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EINPROGRESS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注:errno是线程安全的，每个线程都保留一份errno。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;纸上得来终觉浅，绝知此事需躬行&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Feb 2018 15:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//SocketConnect/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//SocketConnect/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
  </channel>
</rss>
