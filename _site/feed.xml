<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome my site</title>
    <description>中国计量大学本科 通信工程 在读(2017)
 
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 30 Jan 2018 16:02:14 +0800</pubDate>
    <lastBuildDate>Tue, 30 Jan 2018 16:02:14 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>TCP缓冲区与write系统调用</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景：&lt;/h3&gt;
&lt;p&gt;在非阻塞多线程TCP网络编程中，设想一个场景:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;程序A想通过TCP连接发送100KB的数据,我们通过系统调用write()来写入数据。因为我不希望程序长时间阻塞在write()，我希望操作系统迅速将我的100KB数据放入TCP缓冲区，然后write()系统调用返回，内核自动将我们的100KB数据通过TCP发送出去。这里不经有个疑问:TCP缓冲区可以放下我的100KB数据么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上的&lt;em&gt;TCP缓冲区&lt;/em&gt;我故意描述的比较有歧义，网上很多关于TCP缓冲区大小的资料都有一定的误导。首先查阅Linux man手册：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SO_SNDBUF—————-
          Sets or gets the maximum socket send buffer in bytes.  The
          kernel doubles this value (to allow space for bookkeeping
          overhead) when it is set using setsockopt(2), and this doubled
          value is returned by getsockopt(2).  The default value is set
          by the /proc/sys/net/core/wmem_default file and the maximum
          allowed value is set by the /proc/sys/net/core/wmem_max file.
          The minimum (doubled) value for this option is 2048.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我随即查看我的电脑上的配置&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;运行结果：&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wmem_default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;套接字缓冲区大小&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;写&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;212992&lt;/span&gt; 
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_wmem&lt;/span&gt;   
&lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;	&lt;span class=&quot;mi&quot;&gt;16384&lt;/span&gt;	&lt;span class=&quot;mi&quot;&gt;4194304&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;为了确认这些数据，我在自己电脑上用以下程序做了实验:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//#include some head file
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optlen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPPROTO_TCP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getsockopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOL_SOCKET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SO_SNDBUF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;error&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;val:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optval&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;结果是16384。&lt;/p&gt;

&lt;p&gt;为什么我程序输出的却是/pro/sys/ipv4/tcp_wmen的默认值呢？我迷惑了，难道是Linux man 手册说错了?&lt;/p&gt;

&lt;p&gt;这是网上相当多博客最大的误解，有人将其看作是TCP缓冲区大小，有人将其看作是TCP发送窗口大小。&lt;/p&gt;

&lt;p&gt;后来我在IBM的文档中找到了这么一行:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;/proc/sys/net/ipv4/tcp_wmem	 4096 16384 131072	
—–为自动调优定义每个 socket 使用的内存。第一个值是为 socket 的发送缓冲区分配的最少字节数。第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我彻底明白了，每当我们新建一个socket，Linux内核认为大多数时候我们并不会用到如此之大的socket缓冲区，为了内存方面的考虑，所以用16384 = 16KB作为优化值。当我们的数据大于16KB时，是会自动往上增加的，一直到/pro/sys/net/wmem_default,也就是212992 = 208KB。
看到这里，有人会有疑问，也是我在网上搜索资料时遇到的误解:&lt;strong&gt;滑动窗口最大才2^16 = 65536 = 64KB，你这208KB怎么还比64KB大了？&lt;/strong&gt;
为此我又重新翻阅了一下«TCP/IP VO.1»&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;就 window scaling 来说，TCP 最初可以支持最大为 64KB 的窗口（使用 16 位的值来定义窗口的大小）。采用 window scaling（RFC 1323）扩展之后，您就可以使用 32 位的值来表示窗口的大小了。GNU/Linux 中提供的 TCP/IP 栈可以支持这个选项（以及其他一些选项）。提示：Linux 内核还包括了自动对这些 socket 缓冲区进行优化的能力（请参阅下面 表 1 中的 tcp_rmem 和 tcp_wmem），不过这些选项会对整个栈造成影响。如果您只需要为一个连接或一类连接调节窗口的大小，那么这种机制也许不能满足您的需要了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么我的电脑上有没有这所谓的window scaling呢？&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;运行结果：&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipv4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_window_scaling&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;有的。依稀记得好像有这么一句化：当前的以太网带宽发展很快，以前的双绞线10MB以太网现在已经发展到千兆以太网，所以16位的窗口值在一些场合已经不适用了。&lt;/p&gt;

&lt;h5 id=&quot;用一个例子来理解一下上面所说的概念socket缓冲区大小&quot;&gt;用一个例子来理解一下上面所说的概念:socket缓冲区大小&lt;/h5&gt;
&lt;p&gt;举个小例子：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;当我们建立一个socket的时候，内核自动给我分配的是16KB的缓存区,假设程序有100KB数据，我们调用write(fd,data)将数据写入的是套接字缓冲区，由于100KB &amp;gt; 16KB ，缓冲区自动增大，由于100 &amp;lt; 208 故，操作系统将数据从用户态拷到内核缓存区后，write系统调用就返回了，然后TCP从该缓冲区中取数据，TCP得搬运好多次，但是这都是内核的事情，我们管不着。如果数据是209KB，很显然，write()调用势必要阻塞了，阻塞到什么时候?我的理解是,阻塞到TCP将多余的1KB发送出去，并收到回复。(例子可能不是很恰当,如果有不明确的自己google吧)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这下我放心了，100KB是可以放下的。但是我不免有点后怕，我并不确定我的程序到底会有多大的数据,如果下次我们数据是250KB怎么办？我并不想程序阻塞在这里，我得尽快抽身去忙活其它紧急的事情，那该怎么办呢？往下看。&lt;/p&gt;

&lt;h3 id=&quot;如何解决write调用阻塞的问题&quot;&gt;如何解决write调用阻塞的问题？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.&lt;strong&gt;将accept返回的已连接TCP套接字设置成non-blocking&lt;/strong&gt; —— 比方我要写100KB，假设内核只接收了64KB,这时候,write写了64KB之后会返回,程序不会阻塞在这里，而是继续运行。那么又会引入另一个问题,&lt;strong&gt;剩余的36KB数据怎么办？&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;2.&lt;strong&gt;在程序中引入应用层缓冲区&lt;/strong&gt;——对于应用程序来说,我只管产生数据,并调用sendMessage()函数,你最终要分几次发送我不管,但是你不能阻塞我。具体做法是,封装sendMessage()函数:
    &lt;blockquote&gt;
      &lt;p&gt;判断write函数的返回值,将剩余的数据丢给Buffer,注册POLLOUT事件,等到对应的fd可读时，再将数据写入。这时候还有&lt;em&gt;第二点好处&lt;/em&gt;,当buffer有多余数据时，我们可以判断出socket缓冲区已经满了，我们不要调用write(),而是应该将数据添加到buffer中统一写入，这样做好处是什么：&lt;strong&gt;省了一次系统调用,岂不是美滋滋!&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如何确定要多大的socket缓冲区是不是越大越好&quot;&gt;如何确定要多大的socket缓冲区，是不是越大越好？&lt;/h3&gt;

&lt;p&gt;IBM是这么说的,&lt;em&gt;&lt;a href=&quot;https://www.ibm.com/support/knowledgecenter/en/SSQPD3_2.6.0/com.ibm.wllm.doc/UDPSocketBuffers.html&quot;&gt;click heare link to IBM!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;On the Linux platform Tx ring buffer overruns can occur when transmission rates approach 1Gbps and the default send socket buffer is greater than 65536. It is therefore recommended to set the net.core.wmem_default kernel parameter to 65536 bytes on all Linux systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就说在千兆以太网上，为了避免产生TX环形缓冲区溢出，我们最好将core/net/wmem_default设置成小于65536,也即64KB的一个值。但是这可是占内存的，如果我们给每一个socket都设置64KB，不考虑虚拟内存,假设机器内存是4GB，4GB / 64 KB = 16K，也即理论上在4G机器上，我们最多连接16K个TCP连接，这当然是不能接收的。所以这个问题要用毛泽东思想来解决：具体问题具体分析！&lt;/p&gt;

&lt;h3 id=&quot;如何确定应用层buffer的大小&quot;&gt;如何确定应用层Buffer的大小？&lt;/h3&gt;

&lt;p&gt;同样，这也是占内存的,我们不能过大也不能过少，这看起来好像也无解。&lt;/p&gt;

&lt;p&gt;这里推荐一个&lt;strong&gt;&lt;a href=&quot;https://github.com/chenshuo/muduo&quot;&gt;Muduo网络库&lt;/a&gt;&lt;/strong&gt;的做法:动态增长。具体做法是，给每个Buffer初始分配1024B字节，并在栈上分配一个65536字节的数组。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读取：使用readv,buffer作为第一个地址，数组作为第二个地址，这样超过1024的数据全都读到了数组上，等读取结束在将buffer扩增，将数组内的数据追加到buffer。&lt;/li&gt;
  &lt;li&gt;写入：比较简单，判断一下长度即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做利用了临时栈上空间，避免每个连接的初始Buffer过大造成内存浪费，也避免反复调用read()的系统开销。&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 15:13:17 +0800</pubDate>
        <link>http://localhost:4000/TcpBuffer/</link>
        <guid isPermaLink="true">http://localhost:4000/TcpBuffer/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>考研-从头到尾</title>
        <description>&lt;hr /&gt;
&lt;p&gt;因为种种原因，从宇视辞职后，仿惶无依一个月，开始计划考研。&lt;/p&gt;

&lt;p&gt;既然要考研了，当然要选择自己最感兴趣的专业，毫无疑问，我打算往计算机方向发展。&lt;/p&gt;

&lt;p&gt;之前也了解过，计算机考研有四门专业课，分别是数据结构、计算机组成原理、操作系统原理、计算机网络。即使我之前看过数据结构(并基本实现过所有代码，自认为学的还可以)和TCP/IP卷一，可是随着复习进度的推进，我发现老本很快就被我吃完了，导致有点拖进度。&lt;/p&gt;

&lt;h3 id=&quot;今天是2017-7-29&quot;&gt;今天是2017-7-29&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;自从我着手复习已经有一个月整。距离考研还有4个月20天，除去生产实习的15天，我大概还剩下4个月时间，感到了时间的紧迫。按照计划，这个月结束我应该要把高等数学二本教材、数据结构、计算机组成原理过一遍的，现在的情况是高等数学还有一章，数据结构还有小半本书，计算机组成原理还有两章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;造成这个结果的原因其实很简单:&lt;/p&gt;

&lt;p&gt;1、看书不够快&lt;/p&gt;

&lt;p&gt;2、不够努力。除去晚上2个小时的看考研英语视频，我每天花在学习上面的时间只有5个小时,
况且我还给自己每周分配了两天假期。&lt;/p&gt;

&lt;p&gt;理一下下个月的计划：&lt;/p&gt;

&lt;p&gt;1、每天做两个小时高等数学习题。&lt;/p&gt;

&lt;p&gt;2、过一遍线性代数和概率论。&lt;/p&gt;

&lt;p&gt;3、结束计算机组成原理、数据结构。开始操作系统和计算机网络的复习。&lt;/p&gt;

&lt;p&gt;4、英语单词无论如何都要结束第二部分了，阅读理解恐怕也要开始了，感觉有点强行上阅读理解的意味。&lt;/p&gt;

&lt;p&gt;时间安排：&lt;/p&gt;

&lt;p&gt;1、早上再也不能像之前那样8点起床了，因为太热了! 提前到7点吧。&lt;/p&gt;

&lt;p&gt;2、中午不打算回寝室睡觉了，在教室趴着睡觉吧。&lt;/p&gt;

&lt;p&gt;3、晚上10.30之前说什么都要上床了。&lt;/p&gt;

&lt;p&gt;4、所以具体的安排是:&lt;/p&gt;

&lt;p&gt;4.1 早上7.45到达考研教室，高等数学干到9.45。10点开始线性代数和概率论。&lt;/p&gt;

&lt;p&gt;4.2 中午11.30准时去吃饭，12.10开始睡觉，1.30睡醒。1.45开始专业课直到5点吃完饭。&lt;/p&gt;

&lt;p&gt;4.3 6点开始学英语,直到8.30。&lt;/p&gt;

&lt;p&gt;4.4 跑步和仰卧起坐得抓紧时间了。&lt;/p&gt;

&lt;h3 id=&quot;update-in-2017-9-9-night&quot;&gt;update in 2017-9-9 night&lt;/h3&gt;

&lt;p&gt;明天就大四了，今天又是礼拜六，说不准有关心我的人时刻关注着我的状态。所以我来更新一下。&lt;/p&gt;

&lt;p&gt;总之，还行吧，具体细节不是完全符合上述目标，但是也差不多。&lt;/p&gt;

&lt;p&gt;呃，还是说点具体的吧。专业课总共四门，得益于大三之前的积累，所幸我和科班学生的差距没有
想象中的大，很多知识点原来我已经知道了，只是我不知他们的专业术语，所以这次专业课的学习
算的上是一次解惑，很多东西我一看发现，哦！原来它已经在我的脑子里，只是我叫不出来它
的名字。&lt;/p&gt;

&lt;p&gt;唔，我的意思不是我对这些东西掌握的很好、我能得个高分。我只是想表达：你现在做的所有事情，
在不久的将来也许都用的上。&lt;/p&gt;

&lt;p&gt;这一次了学习到的东西，价值远远超过了分数所能代表的意义。
其中收获最大的是英语单词和计算机知识的扫盲。&lt;/p&gt;

&lt;p&gt;就考研来说，我认为最大的困难不是如何取解决难题获得更多的分数，而是尽量
不失分，这肯定是考试的诀窍。所以我准备在这个方面试一试。高考的就是一个例子，我
认为我已经尽力了，我不信我是真的stupid，肯定是哪里出问题了，我要用考研来验证一下。&lt;/p&gt;

&lt;p&gt;好吧，今天就说这么多。&lt;/p&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 14:13:17 +0800</pubDate>
        <link>http://localhost:4000/masterPlan/</link>
        <guid isPermaLink="true">http://localhost:4000/masterPlan/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>C++fucnion模板类与函数指针</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;这篇文章主要记录一下stdfunction和函数指针&quot;&gt;这篇文章主要记录一下std::function&amp;lt;&amp;gt;和函数指针。&lt;/h3&gt;

&lt;font size=&quot;4&quot;&gt; 补上一篇关于回调函数的文章遗留问题，时隔一个月，偶然间在Muduo源码中看到了使用boost::funcion&amp;lt;&amp;gt;模板类来回调函数，统一了normal funcion和non-static member funcion。关于这个功能在C++Primer上也有介绍，痛恨自己之前阅读C++Primer的时候竟然没留意这个功能。最近发现自己废话有点多，不多说了，按照惯例直接先上代码：当回调函数是C++  non-static member function 的另一种解决办法。  &lt;/font&gt;

&lt;p&gt;&lt;img src=&quot;../material/FUNCTION/code1.png&quot; alt=&quot;代码&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;运行结果：&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很明显哦，这个问题的第二种解决方式(不使用static)已经找到。&lt;/p&gt;

&lt;p&gt;上面这个例子中，如果我们把pfunc的类型换成普通成员函数指针(也就是把第三行注释去掉,注释第四行)，由于要类成员函数要传递this指针的缘故，不允许这么干，具体看我上一篇博客中说明。&lt;/p&gt;

&lt;h3 id=&quot;下面开始说c中的函数指针&quot;&gt;下面开始说C++中的函数指针&lt;/h3&gt;

&lt;p&gt;废话不多说，直接上一个例子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/FUNCTION/code2.png&quot; alt=&quot;代码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意看普通成员函数指针的写法，以及调用方式。&lt;/p&gt;

&lt;p&gt;static将改变函数访问方式，以至于可以用普通函数指针来指向它。&lt;/p&gt;

&lt;p&gt;我对其中的原理并不是了解的很清楚，《深入探索C++对象模型》一书中估计可以找到详细的答案。&lt;/p&gt;

</description>
        <pubDate>Wed, 07 Jun 2017 20:12:52 +0800</pubDate>
        <link>http://localhost:4000/functionClass/</link>
        <guid isPermaLink="true">http://localhost:4000/functionClass/</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>当回调函数是C++类成员函数</title>
        <description>&lt;hr /&gt;
&lt;p&gt;今天在公司实习，领导为了让我熟悉公司底层服务端架构，给我两天时间写一个基于当前平台的多线程收发消息的Demo。我参考项目中的旧代码编写这个Demo，平台上有个接口是注册回调函数的，我参照接口函数参数类型一一编写，最后碰到一个编译错误，百思不得其解，后来是同事提醒这里需要加个static关键字，他说C++回调函数必须是static，我一脸茫然。他让我去看static关键的作用，我说我都知道呀，static嘛，balabala…..。他说对啊，所以这里要加static。我还是一脸茫然，为了不暴露我&lt;strong&gt;菜&lt;/strong&gt;的事实，只好点头说是。下班后深究之下，终于发现了问题根源,同事说的并不是全对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本次发现的问题: C++类成员函数不遵守默认函数调用约定(__cdecl),因为要传递this指针&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看下面的例子:&lt;/p&gt;
&lt;h3 id=&quot;普通的回调&quot;&gt;普通的回调:&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../material/CALLBACK/normal_callback.png&quot; alt=&quot;普通回调函数&quot; /&gt;
很正常，函数正常运行。&lt;/p&gt;
&lt;h3 id=&quot;c成员函数作为回调函数&quot;&gt;C++成员函数作为回调函数&lt;/h3&gt;

&lt;p&gt;现在我们来看，&lt;strong&gt;当回调的函数是某个对象的成员函数的时候&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/CALLBACK/class_memberfunction.png&quot; alt=&quot;C++回调&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们编写类成员函数类型，和接口要求的回调函数参数类型&lt;strong&gt;“完全一样”&lt;/strong&gt;,好，我们编译一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/CALLBACK/compile_error.png&quot; alt=&quot;C++回调编译结果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么会这样？函数指针不都只这么用的么，而且怎么还和static搭上了关系？根据编译器的提示，我上网找资料，终于发现了症结所在，算是今天最大的收获了！&lt;/p&gt;

&lt;h3 id=&quot;找原因&quot;&gt;找原因&lt;/h3&gt;
&lt;p&gt;要从C++对象模型说起，&lt;strong&gt;this指针&lt;/strong&gt;。我们知道,普通的C++类,其成员函数是类的所有对象共享的,而数据时每个对象所独有的.即:&lt;strong&gt;数据独有,方法共享&lt;/strong&gt;。因此在调用类的某个成员方法(非静态方法)时,我怎么知道是哪个对象调用的呢?此时就是通过this指针来区分的，通过this指针我可以区分是该类的哪个对象正在调用该成员方法。&lt;/p&gt;

&lt;p&gt;这里不得不提一下这次的另一个收获：&lt;strong&gt;函数调用约定&lt;/strong&gt;，下面是其中三种:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、__cdecl
    __cdecl调用约定成为C调用约定，是&lt;strong&gt;C/C++语言缺省的调用约定&lt;/strong&gt;。参数按照从右至左的方式入栈，函数本身不清理栈，返回值在EAX中，允许可变参数函数存在，如：int printf(char* buffer,const char* format,…);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2、__stdcall 函数自身清理栈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3、__thiscall 这是C++语言特有的一种调用方式，用于类成员函数的调用约定。如果参数确定，this指针存放于ECX寄存器，函数自身清理堆栈；如果参数不确定，this指针在所有参数入栈后再入栈，调用者清理栈。__thiscall不是关键字，程序员不能使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C++类成员函数调用时，实际传递了&lt;strong&gt;this&lt;/strong&gt;，如:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//在编译器看来，A::func最终会转化成 Type func(A *this);
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样看来，我们找到了编译器提示错误的原因，&lt;strong&gt;仅仅是函数参数类型不匹配而已!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;解决方式&quot;&gt;解决方式&lt;/h3&gt;
&lt;h4 id=&quot;1用static修饰类成员函数并且改变调用接口&quot;&gt;1、用static修饰类成员函数,并且改变调用接口&lt;/h4&gt;

&lt;p&gt;但是，问题又随之而来，我们的回调函数是类的成员函数的目的之一：希望通过这个函数来访问对象的资源。但是，&lt;strong&gt;我们函数又是static的，只能访问静态数据成员&lt;/strong&gt;，怎么办？看来显式传递this指针无法避免，即：修改接口，另外加一个参数,用以放置this，如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/CALLBACK/static_solution.png&quot; alt=&quot;静态解决方式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种解决方式勉强可用把，但不是很满意！&lt;/p&gt;

&lt;h4 id=&quot;2肯定还有其他更好的方法暂时没想出来哈哈哈&quot;&gt;2、肯定还有其他更好的方法，暂时没想出来，哈哈哈！&lt;/h4&gt;

&lt;p&gt;来更新一波，使用std::function&amp;lt;&amp;gt;类模板也可以实现这个功能！显示传递this指针即可。因为funciton和C语言的函数指针有点小区别，打算改日另开一篇文章专门记录一下std::function&amp;lt;&amp;gt;和函数指针的区别与联系            2017-6-7&lt;/p&gt;

</description>
        <pubDate>Sat, 20 May 2017 21:09:12 +0800</pubDate>
        <link>http://localhost:4000/callback/</link>
        <guid isPermaLink="true">http://localhost:4000/callback/</guid>
        
        
        <category>C++</category>
        
      </item>
    
      <item>
        <title>我的这一次选择</title>
        <description>&lt;hr /&gt;
&lt;p&gt;这几个月是我最焦虑的日子了，哈哈哈，身边的大多数同学应该也是这个状态，要在就业和继续学习之间做一个抉择。好残酷，必须让你做一个选择。受限于眼界，我是从大一就决定的不考研，虽然现在觉得考研真的很有必要,真的！如果你知道你自己想要什么、追求什么，工作和考研都差不多，两者相比考研更佳。很多人关心我，劝我考研，包括我妈妈。我一意孤行，还是选择了直接就业，当然了，暂时是这么想的，因为我就是这么一个“善变”的人，说不定我明天就去考研了。&lt;/p&gt;

&lt;p&gt;我现在选择的工作和我大一所想的真是天差万别，但是我一点不后悔！我选择通信工程这个专业，我不是盲目的，跟好多同学相比，这一点我很感激自己。我选择这个专业的原因我已经想不起来，也无从考证了。我只记得，我没上大学之前对于&lt;strong&gt;遥控&lt;/strong&gt;这个概念印象很深！我小时候(小学)能接触的最高级的玩具就是遥控小车了，我还能想起来的是我为了买这个遥控小车花了将近一个月在山上摘茶叶，从茶叶萌芽到茶叶花谢。至于飞机与小船我都是看别人玩的,我们那里不卖这种高级货。我好奇心还是很强的，玩了每几天我就把它拆了，我想弄明白里面的故事。看着里面的电路板我当时就明白了，再拆100个也无济于事,这差距就像一只毛毛虫想要打败大灰熊,判若云泥。后来我还拆了一个东西，小霸王学习机。&lt;/p&gt;

&lt;p&gt;一个人的兴趣会影响他很长一段时间。&lt;/p&gt;

&lt;p&gt;所以大一的时候，实验室招新，我没有犹豫就参加了。在实验室的这两年，还真是学到了不少，至少给我建立了一个完整的知识体系,我非常感谢。知识真是可以完全改变一个的野心，到现在，那些玩具已经不在话下了,这个兴趣也就到此为止了！这是我后来离开这个领域的其中一个原因,当然还有一个蛮重要的原因就是，如果我想在这方面有所建树，我必须考研。&lt;/p&gt;

&lt;p&gt;大学提倡的自由，给我的一个负面影响是，对于不感兴趣的东西，我坚持不了15分钟的全神贯注。我是有体会的，我高中的时候，即使不喜欢化学，我还是可以看一下午的化学题，但是现在，你如果让我看两个小时的工程图学，比今天早上的1000米体测还难受！&lt;/p&gt;

&lt;p&gt;大三上学期是我的一个过渡期，我每天都在犹豫，犹豫了一整个学期，后来还是选择了写代码。电路、嵌入式是我的舒适区，离开舒适区的前一段时间是很痛苦的，因为什么都是陌生的，我看不到希望。所以我花很多精力来适应，我的效率是很低的，主要原因是脑子不聪明，所以我选择多花时间。比如大年三十晚上还在写代码、在看招聘网上的职位要求。&lt;/p&gt;

&lt;p&gt;后来看了一个寒假的书之后，我就试着去找实习，前期投简历真是打击我自信心，反馈给我的信息都是:经验不足。也的确，我才学了二十多天，所以我连面试机会都拿不到。这个实习找了整整二个半月，这个期间有几个时间点我真是有点坚持不下去了，我多次给自己暗示，如果这次简历没反馈，我就去考研。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;谢谢我的室友在这期间一直鼓励我！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后来终于有了一次面试机会，是杭州边锋网络的游戏研发,因为方向的不同，我没去面试。但至少给了我一点安慰，我开始变得有竞争力了。&lt;/p&gt;

&lt;p&gt;所以我又高高兴兴开始学习了！学习这件事，我是一点都不排斥的。相反，我挺喜欢的。当然啦，我是指我感兴趣的东西。自学真的是一件困难的事情，原因还是一样，因为你不知道方向是否正确，我每天还是很焦虑。&lt;/p&gt;

&lt;p&gt;后来又有两次面试机会，一次是奥克斯集团、一次是宇视科技。前者HR欺骗我，我就不提了，后者的面试我通过了。我笔试部分做的很不错，面试也没出现什么失误，面试官说我很优秀，比好多应届生还好！那一刻，我真是热泪盈眶！面试官没有看不起我不是科班的身份，也没在意我经验不足，还给了我一些中肯的建议。所以后来的发给我的offer我直接就答应了！哦，对了，他们公司的HR声音真好听！&lt;/p&gt;

&lt;p&gt;那天是我三个月来最开心的一天。&lt;/p&gt;

&lt;p&gt;所以我后来回到学校，就请我室友吃了一次&lt;strong&gt;大份&lt;/strong&gt;的小龙虾，哈哈哈哈！&lt;/p&gt;

&lt;p&gt;距离拿到offer已经过去了半个月，这半个月真是爽到不行，早就把之前的雄心壮志扔到下水道了，整天游手好闲！光是小龙虾就吃了三回！不得不说，吃了好几家，小龙虾还是兰溪的“红火龙虾馆”最好吃！&lt;/p&gt;

&lt;p&gt;马上就要去公司上班了，目的也很简单，我就是去打打酱油，学习学习正规军是如何作战的！希望几个月后的秋招能找个好工作！&lt;/p&gt;

&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。我觉得自己会永远生猛下去，什么也锤不了我。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;离大学本科毕业还有将近一年，时间是个一去不回的游戏，且行且珍惜！&lt;/p&gt;

&lt;h4 id=&quot;黄沙百战穿金甲不破楼兰誓不还&quot;&gt;黄沙百战穿金甲，不破楼兰誓不还&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../material/IDPhoto/idphoto.jpg&quot; alt=&quot;美照,哈哈哈&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS:我知道过几天我回头看这篇文章我肯定会不好意思，哈哈哈！再见！&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 07 May 2017 13:17:00 +0800</pubDate>
        <link>http://localhost:4000/mytracks/</link>
        <guid isPermaLink="true">http://localhost:4000/mytracks/</guid>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>维特比算法的实现</title>
        <description>&lt;hr /&gt;
&lt;p&gt;前几天做通信原理的实验，发现网上关于维特比算法的解释太理论化，我结合代码通俗话的解释一下。如果看了以下代码您还是不能理解维特比纠错算法的真实目的，请务必联系我！&lt;/p&gt;

&lt;p&gt;首先，我问大家一个问题，如下：
&lt;img src=&quot;../material/VTB/route_guess.png&quot; alt=&quot;路径猜测&quot; /&gt;
  A，B，C代表三个地点，三条实线代表路径。假设张三现在要去A、B、C的其中一个地方，由于淘宝上买了一个劣质的指南针，方向出了偏差，虚线是他走过的路，我们不知道到底偏了多少。我们以上帝视觉&lt;strong&gt;猜测&lt;/strong&gt;张三的目的，显然：&lt;strong&gt;看上去张三的目的地好像是B&lt;/strong&gt;。如果我们信赖这个指南针(偏的并不离谱),那么我们的结论也许就是对的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意哦&lt;/strong&gt;,我们的结论是根据最近的地点距离猜得，并不是非常准确，也就是说张三的目的地是A也是有可能的，即:&lt;strong&gt;指南针偏的的太多了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里的”偏的太多了”，在通信上可以认为信息在传输过程受到了非常大的干扰，导致接收到的信息已经面目全非，想要恢复原有信息的话已经不太可能。&lt;/p&gt;

&lt;p&gt;这就是维特比算法的一部分,&lt;strong&gt;根据汉明距离来选择最有可能通往下一个节点的路径&lt;/strong&gt;。所以说，如果信息位错的太离谱了，它就不可靠了，这个不离谱是有一个&lt;strong&gt;度&lt;/strong&gt;的，具体是多少，您可以参考下面的代码做个实验。&lt;/p&gt;

&lt;p&gt;对了！如果您不知道什么是&lt;strong&gt;汉明距离&lt;/strong&gt;，那么您可以直接关掉这个页面了。&lt;/p&gt;

&lt;p&gt;好了，接下来我们来模拟一下整个信息传输过程,我默认您已经掌握了一定的原理，知道什么是M序列、卷积码等。&lt;/p&gt;

&lt;h3 id=&quot;第一步产生m序列&quot;&gt;第一步：产生M序列&lt;/h3&gt;

&lt;div class=&quot;language-matlab highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mseq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fbconnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fbconnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;mseq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;%m序列的第一个输出码元&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;newregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fbconnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;newregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newregister&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mseq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中fbconnection就是我们要发送的信息，它被认为是M序列的特征方程的阶次。&lt;/p&gt;

&lt;p&gt;我们把它定义成函数，将这个文件命名为:createMsequence.m,在matlab中，输入：vector = createMsequence(…,…)就可以产生一个信息段对应的M序列。示列：&lt;/p&gt;

&lt;div class=&quot;language-matlab highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;mes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;%我们要发送的信息,我这里假设是4位，当然不论多少位都是可以的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;%寄存器初始值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mseq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createMsequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;%调用之前我们写的代码&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;运行实例&quot;&gt;运行实例:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../material/VTB/Mseq.png&quot; alt=&quot;M序列的产生&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;加密卷积&quot;&gt;加密、卷积&lt;/h3&gt;

&lt;p&gt;我们先随机产生一个和M序列等长度的01码，我们把这个序列认为是密码子，也就是说接收方如果想要结算它接收到的信息，必须依靠这个密码子。&lt;/p&gt;

&lt;h4 id=&quot;加密&quot;&gt;加密&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;secret = randint(1,length(mseq));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;加密函数就简单点，直接异或吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mseq = bitxor(mseq,secret);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们现在再来看一下差异。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/VTB/secret.png&quot; alt=&quot;secret&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;卷积&quot;&gt;卷积&lt;/h4&gt;

&lt;p&gt;然后我们再对这个序列进行卷积,我采用的是最简单的3,1,3卷积:&lt;/p&gt;

&lt;div class=&quot;language-matlab highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;conv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;xor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是3,1,3卷积编码的实现，具体的实现框图我相信您肯定知道的，不难的，不就是一个迭代么。&lt;/p&gt;

&lt;h3 id=&quot;信道传输&quot;&gt;信道传输&lt;/h3&gt;

&lt;p&gt;我们知道信号的传输过程受环境影响很大，有干扰的情况下很容易造成信息位错乱，其实就是抽样判决的时候导致的。&lt;/p&gt;

&lt;p&gt;假设信号序列在传输过程中出错了，导致了某些位由原来的1-&amp;gt;0,0-&amp;gt;1，我们就令第3、4位吧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;convolution(3) = ~convolution(3);
convolution(4) = ~convolution(4);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../material/VTB/channeltransform.png&quot; alt=&quot;信道传输&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;第四步接收差错纠正&quot;&gt;第四步：接收、差错纠正&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;recevive = convolution;
decode_out = decode(recevive);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;嘿嘿，全文的重点来了，&lt;strong&gt;维特比解码算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里我就直接贴代码了，相信我，如果您专心取理解每一行代码，肯定是看得懂的！&lt;/p&gt;

&lt;p&gt;维特比算法的原理呢，如果您看不懂，结合下面的代码来看会有事半功倍的效果！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%MemeTao 2017.4.16 
%维特比算法 仅支持(3,1,3)卷积码 
%PS:请在调用前保证序列长度 &amp;gt;= 3*3   为什么? 这不是常识么？！
function [out] = receive(vector)
len = length(vector);   %获取输入序列长度
if(mod(len,3) &amp;gt; 0)
    disp('fuck you!');  %序列长度肯定是3的倍数，因为313卷积码嘛!
end 
%下面我要开始初始化route了
%如果您看不懂下面的路径初始化,
%不用怀疑,绝对是没理解卷积码的逆向推导,请去看书
%a b c d 是状态
%aa ab bc ... 是路径
a = [0 0];
b = [0 1];
c = [1 0];
d = [1 1];

aa = [0 0 0]; 
ab = [1 1 1];

bc = [0 0 1];
bd = [1 1 0];

ca = [0 1 1];
cb = [1 0 0];

dc = [0 1 0];
dd = [1 0 1];
%你还是看不懂？ 那怎么办？下面更看不懂咯！   ^_^   ^_^ 
%按照理论,每一次仅存在8条路径，然后判决出4条幸存路径
%管他呢
route = cell(1,8); 
route_survive = cell(1,4);
status = cell(1,8);
dis_cur = zeros(1,8);
dis_survive = zeros(1,8);
%--------------------------------8条路径+4条幸存-----------------------------------%
route{1} = [aa,aa,aa]; status{1} = a; dis_cur(1) = hanmingDis(route{1},vector(1:9)); 
route{2} = [ab,bc,ca]; status{2} = a; dis_cur(2) = hanmingDis(route{2},vector(1:9)); 
route{3} = [aa,aa,ab]; status{3} = b; dis_cur(3) = hanmingDis(route{3},vector(1:9));
route{4} = [ab,bc,cb]; status{4} = b; dis_cur(4) = hanmingDis(route{4},vector(1:9));
route{5} = [aa,ab,bc]; status{5} = c; dis_cur(5) = hanmingDis(route{5},vector(1:9));
route{6} = [ab,bd,dc]; status{6} = c; dis_cur(6) = hanmingDis(route{6},vector(1:9));
route{7} = [aa,ab,bd]; status{7} = d; dis_cur(7) = hanmingDis(route{7},vector(1:9));
route{8} = [ab,bd,dd]; status{8} = d; dis_cur(8) = hanmingDis(route{8},vector(1:9));

for i = 1 : 4
    if( dis_cur(2*i-1) &amp;lt;= dis_cur(2*i) )
    	route_survive{i} = route{2*i-1};
	    dis_survive(i) = dis_cur(2*i-1);
    else
	    route_survive{i} = route{2*i};
	    dis_survive(i) = dis_cur(2*i);
    end
end

for index = 10 : 3 : len
    %重新产生八条路径
    %case a    状态A,下同                  
    route  {1}  = [route_survive{1},aa];   %增加一条a-a路径
    dis_cur(1)  = dis_survive(1) + hanmingDis(aa,vector(index:index+2)); %更新汉明距离
    route  {3} 	= [route_survive{1},ab];   %增加一条a-b路径
    dis_cur(3)  = dis_survive(1) + hanmingDis(ab,vector(index:index+2)); %更新汉明距离
    %case b:
    route  {5}  = [route_survive{2},bc];   %增加一条b-c路径
    dis_cur(5)  = dis_survive(2) + hanmingDis(bc,vector(index:index+2)); %更新汉明距离
    route  {7} 	= [route_survive{2},bd];   %增加一条b-d路径
    dis_cur(7)  = dis_survive(2) + hanmingDis(bd,vector(index:index+2));
    %case c:
    route  {2}  = [route_survive{3},ca];   %增加一条c-a路径
    dis_cur(2)  = dis_survive(3) + hanmingDis(ca,vector(index:index+2)); %更新汉明距离
    route  {4}  = [route_survive{3},cb];   %增加一条c-b路径
    dis_cur(4)  = dis_survive(3) + hanmingDis(cb,vector(index:index+2)); %更新汉明距离
    %case d:
    route  {6}  = [route_survive{4},dc];   %增加一条d-c路径
    dis_cur(6)  = dis_survive(4) + hanmingDis(dc,vector(index:index+2)); %更新汉明距离
    route  {8}  = [route_survive{4},dd];   %增加一条d-d路径
    dis_cur(8)  = dis_survive(4) + hanmingDis(dd,vector(index:index+2)); %更新汉明距离
    %重新产生幸存序列
    for i = 1 : 4
    	if( dis_cur(2*i-1) &amp;lt;= dis_cur(2*i) )
    		route_survive{i} = route{2*i-1};
    		dis_survive(i) = dis_cur(2*i-1);
    	else
		    route_survive{i} = route{2*i};
		    dis_survive(i) = dis_cur(2*i);
    	end
    end	
end	
%答案就在最后的幸存序列里面
min = realmax();%最大整数
for i = 1 : 4 
	if( dis_survive(i) &amp;lt; min)
	    min = dis_survive(i);
	    tar = i;
    end
end
convolution = route_survive{tar};   %现在找到噪声之前的卷积码了！
%下面进行的是卷积码逆向推回M序列，即我们最终的答案
mse = zeros(1,3);
for index_con = 1 : 3 : length(convolution)
    mse = convolution(index_con:index_con+2);
    if( all( mse(:) == aa(:) ) || all( mse(:) == bc(:) ) || all( mse(:) == ca(:) ) || all( mse(:) == dc(:) ) )
	    out(round(index_con/3)+1) = 0;
    else 
    	out(round(index_con/3)+1) = 1;
    end
end

%简直佩服我自己！哈哈哈！
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;关于汉明距离的计算&quot;&gt;关于汉明距离的计算&lt;/h4&gt;

&lt;p&gt;我认为这个您是可以自己接触的，出于人道主义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function hanmingDis = input(src,cur)
len_src = length(src);
len_cur = length(cur);
if(len_src ~= len_cur)
    disp('error input: len_cur not equal len_src');
end
dis = 0;
for i = 1 : len_cur
    if(cur(i) ~= src(i))
        dis = dis + 1;
    end
end
hanmingDis = dis;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好，我们来测试一下在出现差错的情况下，它是否还能还原信息序列：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/VTB/decode.png&quot; alt=&quot;纠错&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;总结与测试&quot;&gt;总结与测试&lt;/h3&gt;

&lt;p&gt;截至到这里，我们已经完成的工作是： 产生M序列-&amp;gt;加密-&amp;gt;卷积编码-&amp;gt;模拟信道传输-&amp;gt;维特比纠错解码-&amp;gt;还原M序列-&amp;gt;还原最初的信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/VTB/end.png&quot; alt=&quot;end&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果您细心看了，会发现最后一步我没介绍，就留给您自己实现吧!&lt;/p&gt;

&lt;p&gt;PS:如果您需要整份代码，可以在以下地址获取&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MemeTao/MemeTao.github.io/tree/master/material/VTB/code&quot;&gt;代码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 12 Apr 2017 17:13:17 +0800</pubDate>
        <link>http://localhost:4000/VBIT/</link>
        <guid isPermaLink="true">http://localhost:4000/VBIT/</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Markdown</title>
        <description>&lt;hr /&gt;
&lt;p&gt;Markdown manual&lt;/p&gt;

&lt;h3 id=&quot;1-斜体和粗体&quot;&gt;1. 斜体和粗体&lt;/h3&gt;

&lt;p&gt;使用 * 和 ** 表示斜体和粗体。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;这是 &lt;em&gt;斜体&lt;/em&gt;，这是 &lt;strong&gt;粗体&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2-分级标题&quot;&gt;2. 分级标题&lt;/h3&gt;

&lt;p&gt;使用 === 表示一级标题，使用 — 表示二级标题。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是一个一级标题
============================

这是一个二级标题
--------------------------------------------------

### 这是一个三级标题
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。&lt;/p&gt;

&lt;h3 id=&quot;3-外链接&quot;&gt;3. 外链接&lt;/h3&gt;

&lt;p&gt;使用 [描述](链接地址) 为文字增加外链接。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;这是去往 &lt;a href=&quot;http://github.com&quot;&gt;本人博客&lt;/a&gt; 的链接。&lt;/p&gt;

&lt;h3 id=&quot;4-无序列表&quot;&gt;4. 无序列表&lt;/h3&gt;

&lt;p&gt;使用 *，+，- 表示无序列表。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无序列表项 一&lt;/li&gt;
  &lt;li&gt;无序列表项 二&lt;/li&gt;
  &lt;li&gt;无序列表项 三&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-有序列表&quot;&gt;5. 有序列表&lt;/h3&gt;

&lt;p&gt;使用数字和点表示有序列表。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有序列表项 一&lt;/li&gt;
  &lt;li&gt;有序列表项 二&lt;/li&gt;
  &lt;li&gt;有序列表项 三&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6-文字引用&quot;&gt;6. 文字引用&lt;/h3&gt;

&lt;p&gt;使用 &amp;gt; 表示文字引用。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;野火烧不尽，春风吹又生。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-行内代码块&quot;&gt;7. 行内代码块&lt;/h3&gt;

&lt;p&gt;使用 `代码` 表示行内代码块。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;让我们聊聊 &lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;8--代码块&quot;&gt;8.  代码块&lt;/h3&gt;

&lt;p&gt;使用 四个缩进空格 表示代码块。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是一个代码块，此行左侧有四个不可见的空格。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;9--插入图像&quot;&gt;9.  插入图像&lt;/h3&gt;

&lt;p&gt;使用 ![描述](图片链接地址) 插入图像。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://en.wikipedia.org/static/images/project-logos/enwiki-2x.png&quot; alt=&quot;我的头像&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;markdown-高阶语法手册&quot;&gt;Markdown 高阶语法手册&lt;/h2&gt;

&lt;h3 id=&quot;1-标签分类&quot;&gt;1. 标签分类&lt;/h3&gt;

&lt;p&gt;在编辑区任意行的列首位置输入以下代码给文稿标签：&lt;/p&gt;

&lt;p&gt;标签： 数学 英语 Markdown&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;Tags： 数学 英语 Markdown&lt;/p&gt;

&lt;h3 id=&quot;2-删除线&quot;&gt;2. 删除线&lt;/h3&gt;

&lt;p&gt;使用 ~~ 表示删除线。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;这是一段错误的文本。&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-注脚&quot;&gt;3. 注脚&lt;/h3&gt;

&lt;p&gt;使用 [^keyword] 表示注脚。&lt;/p&gt;

&lt;p&gt;这是一个注脚&lt;sup id=&quot;fnref:footnote&quot;&gt;&lt;a href=&quot;#fn:footnote&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;的样例。&lt;/p&gt;

&lt;p&gt;这是第二个注脚&lt;sup id=&quot;fnref:footnote2&quot;&gt;&lt;a href=&quot;#fn:footnote2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;的样例。&lt;/p&gt;

&lt;h3 id=&quot;4-加强的代码块&quot;&gt;4. 加强的代码块&lt;/h3&gt;

&lt;p&gt;支持四十一种编程语言的语法高亮的显示，行号显示。&lt;/p&gt;

&lt;p&gt;非代码示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install vim-gnome
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Python 示例：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@requires_authorization&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;somefunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;'''A docstring'''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# interesting&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Greater'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'''interpreter
... prompt'''&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;JavaScript 示例：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* nth element in the fibonacci series.
* @param n &amp;gt;= 0
* @return the nth element, &amp;gt;= 0.
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5-定义型列表&quot;&gt;5. 定义型列表&lt;/h3&gt;

&lt;dl&gt;
  &lt;dt&gt;名词 1&lt;/dt&gt;
  &lt;dd&gt;定义 1（左侧有一个可见的冒号和四个不可见的空格）&lt;/dd&gt;
  &lt;dt&gt;代码块 2&lt;/dt&gt;
  &lt;dd&gt;这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;代码块（左侧有八个不可见的空格）
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;6-html-标签&quot;&gt;6. Html 标签&lt;/h3&gt;

&lt;p&gt;本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th rowspan=&quot;2&quot;&amp;gt;值班人员&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;星期一&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;星期二&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;星期三&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;李强&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;张明&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;王平&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;7-待办事宜-todo-列表&quot;&gt;7. 待办事宜 Todo 列表&lt;/h3&gt;

&lt;p&gt;使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对应显示如下待办事宜 Todo 列表：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[ ] &lt;strong&gt;Cmd Markdown 开发&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率&lt;/li&gt;
      &lt;li&gt;[ ] 支持以 PDF 格式导出文稿&lt;/li&gt;
      &lt;li&gt;[x] 新增Todo列表功能 &lt;a href=&quot;https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments&quot;&gt;语法参考&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;[x] 改进 LaTex 功能
        &lt;ul&gt;
          &lt;li&gt;[x] 修复 LaTex 公式渲染问题&lt;/li&gt;
          &lt;li&gt;[x] 新增 LaTex 公式编号功能 &lt;a href=&quot;http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers&quot;&gt;语法参考&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[ ] &lt;strong&gt;七月旅行准备&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;[ ] 准备邮轮上需要携带的物品&lt;/li&gt;
      &lt;li&gt;[ ] 浏览日本免税店的物品&lt;/li&gt;
      &lt;li&gt;[x] 购买蓝宝石公主号七月一日的船票&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:footnote&quot;&gt;
      &lt;p&gt;这是一个 &lt;em&gt;注脚&lt;/em&gt; 的 &lt;strong&gt;文本&lt;/strong&gt;。&amp;nbsp;&lt;a href=&quot;#fnref:footnote&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:footnote2&quot;&gt;
      &lt;p&gt;这是另一个 &lt;em&gt;注脚&lt;/em&gt; 的 &lt;strong&gt;文本&lt;/strong&gt;。&amp;nbsp;&lt;a href=&quot;#fnref:footnote2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 12 Oct 2016 17:13:17 +0800</pubDate>
        <link>http://localhost:4000/markdown-manual/</link>
        <guid isPermaLink="true">http://localhost:4000/markdown-manual/</guid>
        
        
        <category>diary</category>
        
      </item>
    
  </channel>
</rss>
