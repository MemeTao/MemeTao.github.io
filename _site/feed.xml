<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome my site</title>
    <description>中国计量大学本科 通信工程 在读(2017)
 
</description>
    <link>http://MemeTao.github.io//</link>
    <atom:link href="http://MemeTao.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 14 May 2021 16:28:33 +0800</pubDate>
    <lastBuildDate>Fri, 14 May 2021 16:28:33 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>webrtc接收端jitter公式推导</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;卡尔曼增益简单介绍及推导&quot;&gt;卡尔曼增益简单介绍及推导&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一把尺子测量一枚硬币的直径, 记录每次测量出的结果:$x_1$, $x_2$, $x_3$, ….&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么, 对硬币直径的估计值:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$\overline{\text{x}}_n$ = ($x_1$+$x_2$+$x_3$+…+$x_n$) / n&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;进一步, 写成递归形式:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$\overline{\text{x}}_n$ = ($x_1$+$x_2$+$x_3$+…+$x_n$) / n&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 14 May 2021 14:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//webrtc-jitter-buffer/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//webrtc-jitter-buffer/</guid>
        
        
        <category>webrtc</category>
        
      </item>
    
      <item>
        <title>google 拥塞控制算法</title>
        <description>&lt;hr /&gt;

&lt;h2 id=&quot;1&quot;&gt;1&lt;/h2&gt;

&lt;p&gt;webrtc中使用gcc(google congestion controller)作为默认的拥塞控制算法,gcc最初发表于: gcc 论文链接. 目的是为了解决以下的问题:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It is known that the well-established TCP congestion control is not suitable for real-time communication due to its retransmissions and in-order delivery mechanisms which induce significant latency. Real-time communication requires not only congestion control but also minimization of queuing delays to provide interactivity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可见, gcc的目的是”minimization of queuing delays”.&lt;/p&gt;

&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;

&lt;p&gt;在gcc中, 主要通过两个指标来衡量网络的情况:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;丢包率&lt;/li&gt;
  &lt;li&gt;延迟梯度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;延迟梯度是这么定义的: 假设网络包1的发送时间是t1, 到达时间是t2. 网络包2到达发送时间是t3, 达到时间是t4, 那么这组包的延迟梯度就等于 (t4-t2) - (t3-t1). 注意, 这里使用的都是各端自己的时间戳所以不需要时间同步. 如果网络没有一点拥塞那么这个值应该是0. 需要特别说明的是: 在工程实现中, 并不是每一个包就计算一个梯度值, 而是一组包计算一次.&lt;/p&gt;

&lt;p&gt;这里有三种情况: &amp;gt;0, =0, &amp;lt;0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/gcc/tidu1.png&quot; alt=&quot;&amp;gt;0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况下, 延迟梯度&amp;gt;0, 我们可以明显看出是网络出现了拥塞.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/gcc/tidu2.png&quot; alt=&quot;&amp;gt;0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种情况下, 延迟梯度小于0, 我们可以推测出网络出现过拥塞, 且正在恢复(姑且先这么认为).&lt;/p&gt;

&lt;p&gt;gcc得的基于丢包 + 基于延迟的估计后, 会对两个值做个权衡, 并输出最终的带宽估计值.&lt;/p&gt;

&lt;h3 id=&quot;基于丢包的带宽估计&quot;&gt;基于丢包的带宽估计&lt;/h3&gt;

&lt;p&gt;论文中的描述非常的简单:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;丢包低于2%, 以1.05的增速提高估计值&lt;/li&gt;
  &lt;li&gt;丢包高于2%, 低于10%, 估计值保持不变(保持这个值, 如果估计值偏高, 丢包会持续增大)&lt;/li&gt;
  &lt;li&gt;丢包大于10%, 以丢包的一半降低估计值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../material/gcc/loss-based-rule.png&quot; alt=&quot;基于丢包的规则&quot; /&gt;&lt;/p&gt;

&lt;p&gt;三条规则非常简单, 工程实现也是非常简洁就不多说了.&lt;/p&gt;

&lt;p&gt;从实际情况的观测中发现, 丢包通常是”剧烈的”, 往往是某一个小片刻内的所有包都丢失, 几乎不存在随机丢包的情况(丢包均匀的分散在时间轴上). 在一些特殊的场景下确实观测到过udp随机丢包: 某些区域跨运营商网络.&lt;/p&gt;

&lt;h3 id=&quot;基于延迟的带宽估计&quot;&gt;基于延迟的带宽估计&lt;/h3&gt;

&lt;p&gt;先简单的说明下gcc选择延迟梯度作为指标的理由之一:&lt;/p&gt;

&lt;p&gt;首先,容易想到的指标是rtt, rtt变大了就表明网络拥塞了. 但是rtt毕竟是一个”two way”值, 不仅和A-&amp;gt;B延迟有关, 还和B-&amp;gt;A的延迟有关, B-&amp;gt;A有拥塞不能说明A-&amp;gt;B也有拥塞.比如多人wifi环境下, 主要是下行流量多, 上行流量比较少.&lt;/p&gt;

&lt;p&gt;所以gcc就提出了一种”one-way”的方式, 就是延迟梯度, 但是这玩意也不是新鲜东西了, 90年代就有人尝试过.&lt;/p&gt;

&lt;p&gt;先抛开数学公式, 从宏观上理解下”&lt;strong&gt;队列延迟&lt;/strong&gt;”:&lt;/p&gt;

&lt;p&gt;网络中A端到达C端, 需要经过很多中间设备: 路由器, 交换机等,统称为R端. 既 A-&amp;gt;R-&amp;gt;C.&lt;/p&gt;

&lt;p&gt;R端转为一个”中间节点”, 主要的功能将A的流量转发给C. 为了较好的执行这个转换, R端需要一个缓冲区, 用来存放A端瞬间输入的过多的来不及完全转发出去的流量.&lt;/p&gt;

&lt;p&gt;队列延迟是因为缓冲区增大引起的, “延迟梯度”的变化趋势其实就是”队列延迟”的变化趋势, 需要特别说明是: 并不是反映”值”, 而是&lt;strong&gt;趋势&lt;/strong&gt;, 这点非常关键.&lt;/p&gt;

&lt;p&gt;(—未完待续—)&lt;/p&gt;

&lt;h4 id=&quot;ack码率的计算&quot;&gt;ACK码率的计算&lt;/h4&gt;

&lt;p&gt;低通滤波器: 贝叶斯估计模型&lt;/p&gt;

&lt;h4 id=&quot;工程实现&quot;&gt;工程实现&lt;/h4&gt;

&lt;p&gt;更新出trend之后:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;over-using 事件:
    &lt;ol&gt;
      &lt;li&gt;in alr, 使用先前的码率作为接收端码率&lt;/li&gt;
      &lt;li&gt;ack 有效, 使用ack作为接收端码率&lt;/li&gt;
      &lt;li&gt;ack 无效, 当前值降低一半作为接收端码率&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;其它信号: 正常aimd处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后的状态机如下:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;swtich&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kNormal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//这段的理解需要看论文中的解释
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kHold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//仅在第一次增加的时候记录时间
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;latest_bitrate_change_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;state_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kIncrease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kOverusing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;state_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kDecrease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kUnderusing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;state_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kHold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 11:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//google-congestion-controller/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//google-congestion-controller/</guid>
        
        
        <category>webrtc</category>
        
      </item>
    
      <item>
        <title>lea和mov指令的真正区别</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;lea指令&quot;&gt;lea指令&lt;/h3&gt;

&lt;p&gt;lea指令的解释是:load effective address.&lt;/p&gt;

&lt;p&gt;网上有很多解释, 比如知乎高赞&lt;a href=&quot;https://www.zhihu.com/question/40720890/answer/110774673&quot;&gt;汇编语言中mov和lea的区别有哪些？&lt;/a&gt; :&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lea是“load effective address”的缩写，简单的说，

lea指令可以用来将一个内存地址直接赋给目的操作数，

例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，

而不是把ebx+8处的内存地址里的数据赋给eax。

而mov指令则恰恰相反，例如：mov eax,[ebx+8]

则是把内存地址为ebx+8处的数据赋给eax。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说的没错, 可是仍旧是没有解释&lt;strong&gt;为什么用mov就不行&lt;/strong&gt;, 比如:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lea eax, &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebx+8]&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 将ebx+8这个值直接赋给eax
难道不等价与:
mov eax, ebx+8&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实,这才是&lt;strong&gt;初学者&lt;/strong&gt;真正想问的问题.&lt;/p&gt;

&lt;p&gt;原因也很搞笑: mov指令不支持这样的格式.&lt;/p&gt;

&lt;p&gt;上面的例子中, 源操作数”ebx + 8” is invalid.&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Apr 2021 08:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//leaVSmov/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//leaVSmov/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>X86汇编笔记</title>
        <description>&lt;hr /&gt;

&lt;p&gt;###notes&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在8086处理器上,如果要用寄存器来提供偏移地址,只能使用BX,si,di,bP,不能使用其它寄存器.以下指令是非法的: mov [ax], dl&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;8086处理器只支持以下几种基地址寄存器和变址寄存器的组合:[bx+si] [bx+di] [bp+si] [bp+di]&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;条件转移指令&quot;&gt;条件转移指令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;js  当SF == 1则跳转 , jns与之相反&lt;/li&gt;
  &lt;li&gt;jz  当zF == 1则跳转,  jnz与之相反&lt;/li&gt;
  &lt;li&gt;jo  当OF == 1则跳转,  jno与之相反&lt;/li&gt;
  &lt;li&gt;jc  当CF == 1则跳转,  jnc与之相反&lt;/li&gt;
  &lt;li&gt;jp  当PF == 1则跳转,  jnp与之相反&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用指令&quot;&gt;常用指令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;movsb | movsw
```shell
DS:SI –&amp;gt; ES:DI
DF = 0 low-&amp;gt;high
DF = 1 high-&amp;gt;low&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;instruction ‘cld’ can clear df&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
* div
A / B. A是被除数, B是为除数.

被除数A默认存在AX中, 或者AX和DX中(DX存高x位)

如果除数是8位，那么除法的结果AL保存商，AH保存余数.

如果除数16位，那么除法的结果 AX保存商，DX保存余数。

* cli &amp;amp;&amp;amp; sti 清除和设置IF(中断标志位)

* repe/repne 相等(ZF==0)/不相等的时候重复

* scasb(w|d) 两个对比数分别为 EAX / AX / AL 和 DS:EDI, 并且将edi-+1（2|4)

### ret
* ret 弹栈到IP寄存器 
* retf 弹栈到IP,再弹栈到CS
* iret 弹栈到IP,再弹栈到CS,再弹栈到FLAGS

### call 指令

call 指令有三种形式:

第一种是16位相对近调用, 近调用的意思是被调用的目标过程位于当前代码段内,而非另一个不同的代码段,所以只需要得到偏移地址即可.

16位相对近调用是三字节指令, 操作码为0xE8. 在指令执行阶段, 处理器看到操作码0xE8, 就知道它应当调用一个过程. 于是,它用指令指针寄存器IP的当前内容加上指令中的操作数, 再加上3, 得到一个新的偏移地址. 接着将IP的原有内容压入栈. 最后,用刚才的偏移地址取代IP原油的内容. 这直接导致处理器的执行流程转移到目标位置处.

第二种是16位间接绝对近调用, 这种调用也是近调用, 只能调用当前代码段内的过程, 指令中的操作数不是偏移量, 而是被调用过程的真实偏移地址, 故称绝对地址. 这个地址不是直接出现在指令中,而是由16位的通用寄存器或者16位的内存单元简介给出. 

第三种是16位直接绝对远调用, 调用另一个代码段内的过程. 
比如: 
```shell
call 0x20000:0x0030
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果被调用过程处于当前代码段, 也没关系.&lt;/p&gt;

&lt;p&gt;第四种是16位间接绝对远调用, 这也属于段间调用,被调用过程属于另一个代码段. 比如:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;call far &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0x2000]
call far &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;bx]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;间接远调用必须使用&lt;strong&gt;far&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;中断&quot;&gt;中断&lt;/h3&gt;

&lt;p&gt;实模式下,处理器要求中断向量表需要存放在物理地址0x00000-&amp;gt;0x003ff,同1k的空间内,共256个中断,每个中断向量4个字节.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x00000 ... -&amp;gt; ....0x003ff
---------------------------------------------
偏移地址(2字节) | 段地址(2字节)    | 偏移地址..
---------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;内联汇编&quot;&gt;内联汇编&lt;/h2&gt;

&lt;h3 id=&quot;常用约束&quot;&gt;常用约束&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;r : Register(s)&lt;/li&gt;
  &lt;li&gt;a: %eax, %ax, %al&lt;/li&gt;
  &lt;li&gt;b: %ebx, %bx, %bl&lt;/li&gt;
  &lt;li&gt;c: %ecx, %cx, %cl&lt;/li&gt;
  &lt;li&gt;d: %edx, %dx, %dl&lt;/li&gt;
  &lt;li&gt;S: %esi, %si&lt;/li&gt;
  &lt;li&gt;D: %edi, %di&lt;/li&gt;
  &lt;li&gt;i: 直接操作数&lt;/li&gt;
  &lt;li&gt;=: 只写&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 12 Dec 2020 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//x84-assembly/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//x84-assembly/</guid>
        
        
        <category>assembly</category>
        
      </item>
    
      <item>
        <title>webrtc带宽预测中的Probe（探测）模块</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;probe&quot;&gt;Probe&lt;/h3&gt;
&lt;p&gt;webrtc使用gcc（google congestion control）来估计带宽，控制当前的发送速度。gcc中基于丢包和基于延迟的算法有个特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.能迅速响应带宽的衰减&lt;/li&gt;
  &lt;li&gt;2.不能迅速响应带宽的增加&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个例子，如果当前带宽是20mbps，由于其它因素，带宽骤降至15mbps，gcc能快速的给出over-using信号(rtt为10ms环境下，响应速度是100-200ms)。&lt;/p&gt;

&lt;p&gt;如果当前带宽是20mbps，由于其它因素，带宽升至了25mbps，依赖gcc自身的调整的话需要几十秒的时间（加性增减性乘的效果）。&lt;/p&gt;

&lt;p&gt;由于以上的原因，如果从0bps开始运行gcc算法（纯算法本身），要达到一定的带宽需要太长的时间。&lt;/p&gt;

&lt;p&gt;webrtc中有一个用来在起始阶段（或周期性）迅速探测到当前带宽的措施—就是Probe模块，和TCP的慢启动比较像啦！&lt;/p&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;Probe的原理简单说起来就是这样的：发送端以一定的速度发送数据包，同时记录这些数据包的发送时间、序列号（全局唯一）、探测组的id.&lt;/p&gt;

&lt;p&gt;接收端每过一段时间（50-150ms）会反馈数据包的到达时间，就像这样：
&lt;img src=&quot;../material/WebrtcProbe/1.png&quot; alt=&quot;probeExample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;s_t表示发送时间、r_t标识接受时间，这样我们就知道了发送速度、接收速度:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//发送端发送这些数据包的时间间隔
common::TimeDelta send_interval = common::TimeDelta(state.last_send - state.first_send);
//接收端接收这些数据包的时间间隔
common::TimeDelta recive_interval = common::TimeDelta(state.last_recive - state.first_recive);
//发送的字节数(已发送的字节减去最后一个数据包的字节，不难理解吧?)
size_t size_send = state.size_total_sent - state.size_last_sent;
//接收端收到的字节数(已接收的字节减去第一个数据包的字节，不难理解吧?)
size_t size_recive = state.size_total_recived - state.size_first_recived;
//从而就得到了双方的速度
common::DataRate send_bps = 1_bps * (size_send * 8 / ( send_interval / 1_sec));
common::DataRate receive_bps = 1_bps * (size_recive * 8 / ( recive_interval / 1_sec));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们定义S1为发送速度，R1为接收速度，那么可以认定当前的网络带宽至少是min(S1,R1)。
在这里涉及到几个问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如何控制发送端的速度&lt;/li&gt;
  &lt;li&gt;探测包的大小如果设置才会比较合理&lt;/li&gt;
  &lt;li&gt;探测应该持续多久，尽可能的避免对正常数据的影响&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;控制探测速度包大小探测时长&quot;&gt;控制探测速度、包大小、探测时长&lt;/h3&gt;
&lt;p&gt;webrtc中探测包是通过一个定时器来控制速度的。&lt;/p&gt;

&lt;p&gt;假设我们需要探测的目标速度是10mbps，探测时间是10ms，&lt;/p&gt;

&lt;p&gt;那么我们总共需要发送的所有探测包的总大小 total_bytes = 10mbps * 15ms  / 8 ;&lt;/p&gt;

&lt;p&gt;第一个探测包的大小取值为 bytes1 = 10_mbps * 1_ms / 8，立即发送。
为了控制速度，我们需要考虑第二个探测包的发送时间，假设是dt时间后发送，计算dt:&lt;/p&gt;

&lt;p&gt;dt = sent_bytes * 8 /  1_mbps;&lt;/p&gt;

&lt;p&gt;意思就是已发送比特数 除以 目标码率，在dt的时间后发送第二个探测包，这样我们就精确地控制了发送速度就是我们希望的速度。&lt;/p&gt;

&lt;p&gt;以这种方式发送数据包，直到”已发送字节”大于等于total_bytes，该轮探测结束。&lt;/p&gt;

&lt;p&gt;上述中15ms就是探测需要持续的时间(可以自定义)，bytes1就是探测包的大小(通过修改”1_ms”可以自定义大小)&lt;/p&gt;

&lt;p&gt;通过一定的手段，我们可以将正常数据流上的数据包变为探测包，减少对正常数据流的影响。&lt;/p&gt;

&lt;p&gt;探测一般都是已当前速度的几倍去发送数据，所以必不可免的会影响当前的数据流，可以修改”15_ms”来自定义探测时长。&lt;/p&gt;

&lt;h3 id=&quot;乘性探测&quot;&gt;乘性探测&lt;/h3&gt;

&lt;p&gt;为了快速的探测到实际带宽的大致值，使用乘性探测。&lt;/p&gt;

&lt;p&gt;举个例子，假设起始速度设置为450kbps，那么探测速度就设置为900kbps，如果探测结果在900kbps * 0.7 = 630kbps以上，继续向上探测，探测速度是1.8mbps，如果第二次探测结果在1.8mbps * 0.7以上，继续向上探测，探测速度是3.6mbps…..直到某一个探测结果不符合 “0.7以上”，那么就判定链路带宽应该在此次探测结果附近。&lt;/p&gt;

&lt;p&gt;然后，以这个速度发送数据流，在这个基础上运行gcc算法，通过延迟梯度和丢包来控制发送码率。&lt;/p&gt;

&lt;h3 id=&quot;实际情况&quot;&gt;实际情况&lt;/h3&gt;

&lt;p&gt;在我的实现中。在rtt 10ms的环境下，可以立刻探测到带宽上限。
运行日志如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;probe successful,send speed:892.845kbps,receive speed:898.797kbps
probe successful,send speed:888.780kbps,receive speed:891.707kbps
probe successful,send speed:1.771mbps,receive speed:1.628mbps
probe successful,send speed:1.777mbps,receive speed:2.214mbps
probe successful,send speed:3.358mbps,receive speed:3.337mbps
probe successful,send speed:3.521mbps,receive speed:3.591mbps
...
probe successful,send speed:30.376mbps,receive speed:31.149mbps
probe successful,send speed:59.897mbps,receive speed:45.238mbps &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;达到带宽上限&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;则认为当前带宽的上限是45.238mbps(我通过tc命令设置的带宽就是45mbps，探测结果非常的准)&lt;/p&gt;

&lt;p&gt;从300kbps的起始速度上升到45mbps，用时800ms。&lt;/p&gt;

&lt;p&gt;在实际环境中，webrtc就是通过该机制在起始阶段迅速的”跳跃”到一个合适的码率上。&lt;/p&gt;

&lt;h3 id=&quot;解答&quot;&gt;解答&lt;/h3&gt;
&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 09:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//webrtc-porber/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//webrtc-porber/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>enable_shared_from_this 实现机制</title>
        <description>&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;template&amp;lt;typename T&amp;gt;
class shared_ptr{
public:
    shared_ptr&amp;lt;T&amp;gt;(T* t)
    {
        set_ptr(this,t);
    }
};

template&amp;lt;typename T&amp;gt;
class enable_shared_from_this{
public:
    shared_ptr&amp;lt;T&amp;gt; shared_from_this(){
        //if sp_ not null
        return sp_;
    }
    void set_ptr(shared_ptr&amp;lt;T&amp;gt; p) {
        sp_ = p;
    }
private:
    shared_ptr&amp;lt;T&amp;gt; sp_; //FIXME:weak_ptr
};

template&amp;lt;typename T&amp;gt;
void set_ptr(shared_ptr&amp;lt;T&amp;gt; t, enable_shared_from_this&amp;lt;T&amp;gt;* e)
{
    e-&amp;gt;set_ptr(t);
}

void set_ptr(...)
{
    //do nothing
}

class t: public enable_shared_from_this&amp;lt;t&amp;gt;{
public:
    t() = default;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用shared_ptr创建t对象时,t对象内部通过set_ptr将这个share_ptr对象包含在自己内部。&lt;/p&gt;

&lt;p&gt;但是这样子的话t永远无法析构自己，所以需要将内部的这个指针改为weak_ptr。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jul 2019 09:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//sharedptrTheory/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//sharedptrTheory/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>Google拥塞控制算法--TrendingLine滤波器</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;延迟梯度&quot;&gt;延迟梯度&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../material/GccTrendingLineFilter/gradient.png&quot; alt=&quot;延迟梯度&quot; /&gt;
左边的Tx表示发送时间，右边的tx表示接收时间。&lt;/p&gt;

&lt;p&gt;延迟梯度的计算公式就是： gt(i) = (t(i) - t(i-1)) - (T(i) - T(i-1))，实际上就是发送间隔和接收间隔的差值。&lt;/p&gt;

&lt;p&gt;网络状态良好的情况下，这个值为0，当网络状态变差(发送端速度不变，接收端速度下降)，这个值为正。&lt;/p&gt;

&lt;p&gt;举个例子：发送端以1mbps的速度发送(每1ms发送1kb数据)，接收端的带宽仅有0.5mbsp，如下图:
&lt;img src=&quot;../material/GccTrendingLineFilter/1mbpssender_0.5mbpsreciver.png&quot; alt=&quot;1mbps0.5mbps&quot; /&gt;
从第一个1kb到第二个1kb，发送端用时1ms，而接收端需要2ms，梯度= 2 -1 = 1ms。观测”延迟梯度”的值，就可以发现发送端和接收端的带宽不对等，需要改变一方的速度。&lt;/p&gt;

&lt;p&gt;考虑下面这一种情况：
&lt;img src=&quot;../material/GccTrendingLineFilter/networking.png&quot; alt=&quot;networking&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发送端与交换机之间的带宽是30mbps，接收端与交换机之间的带宽是10mbps。当发送端以10mbps的速度发送数据时，不考虑其它因素的影响，假设传播时延是10ms，那么任何数据包在10ms内就可以均匀到达接收端。&lt;/p&gt;

&lt;p&gt;当发送端以大于10mbps的速度发送数据时，由于接收端的网络设备的处理能力只有10mbps，会将无法及时转发的流量缓冲在出口队列中。&lt;/p&gt;

&lt;p&gt;模拟这下这种情况：发送端以10mbps的速度发送数据，维持100ms，提高速度到16mbps，维持150ms，下降速度到8mbps，并一直保持这个速度。假设发送端发送的单个报文长度为10k bit。&lt;/p&gt;

&lt;p&gt;前100ms内，接收端的带宽足够，不会有交换机缓冲。接下来的150ms，发送端速度大于接收端的带宽，有一半数据会被缓冲在交换机的队列中，队列长度不断增大，直至丢包。随后发送端速度下降到5mbps，队列中的数据又被不断抽出，直至恢复正常。&lt;/p&gt;

&lt;p&gt;用以下代码对上述情况进行简单的模拟:&lt;/p&gt;

&lt;h4 id=&quot;发送端&quot;&gt;发送端&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;std::vector&amp;lt;Packet&amp;gt; BitSender::send(common::Timestamp at_time)
{
    using namespace common::rate;
    using namespace common::time_interval;
    //初始化
    if(!last_sent_time_.is_valid()){
        last_sent_time_ = at_time;
    }

    size_t bits_will_send = 0;
    std::vector&amp;lt;Packet&amp;gt; packets; 
    bits_will_send = static_cast&amp;lt;size_t&amp;gt;(bps_.value() * 
            ((at_time - last_sent_time_) / 1_sec));
    bits_sent_ += bits_will_send;
    size_t bits_reamin = bits_will_send;
    //向上取整
    long n = std::lround(bits_reamin * 1.0 / kPacketSize);
    for(int i = 0 ; i &amp;lt; n ; i++)
    {
        Packet packet;
        packet.size = kPacketSize;
        packet.send_time = at_time;
        packets.push_back(packet);
    }
    last_sent_time_ = at_time;
    return packets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;转发端&quot;&gt;转发端&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//接受发送端的数据，放到队列中
void BitForwarder::recive(std::vector&amp;lt;Packet&amp;gt;&amp;amp; packets)
{
    for(auto&amp;amp; packet : packets)
    {
        packet.delay = packet.delay + 5_ms; //发送端-&amp;gt;转发端  传输时延
        fifo_.push(packet);
    }
}
//发送队列中的数据
std::vector&amp;lt;Packet&amp;gt; BitForwarder::forward(common::Timestamp at_time)
{
    size_t bits_will_forward = 0;
    if(!last_forwarded_time_.is_valid()){
        last_forwarded_time_ = at_time;
    }
    std::vector&amp;lt;Packet&amp;gt; forward_packets;
    bits_will_forward = static_cast&amp;lt;size_t&amp;gt;(bps_.value() *
            ((at_time - last_forwarded_time_) / 1_sec));
    bits_forwarded_ += bits_will_forward;
    size_t bits_remain = bits_will_forward;
    while(bits_remain &amp;amp;&amp;amp; fifo_.size()){
        if(fifo_.front().size &amp;lt;= bits_remain){
            forward_packets.push_back(fifo_.front());
            bits_remain -= fifo_.front().size;
            fifo_.pop();
        }else{
            break;
        }
    }
    last_forwarded_time_ = at_time;
    return forward_packets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;接收端&quot;&gt;接收端&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void BitReciver::recive(std::vector&amp;lt;Packet&amp;gt;&amp;amp; packets,
        common::Timestamp at_time)
{
    for(auto&amp;amp; packet : packets){
        packet.delay = packet.delay + 5_ms;  //转发端-&amp;gt;接收端 传输时延
        packet.recive_time = at_time;
    }
    record(packets); //对每个包的发送、接收时间进行记录
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;主函数&quot;&gt;主函数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int main()
{
    BitSender sender(0_mbps);
    BitReciver reciver(10_mbps);
    BitForwarder forwarder(reciver.bps());

    const auto start_time = common::Timestamp::now();
    const auto kFirstStageEndTime = start_time + 100_ms;
    const auto kSecondStageEndTime = start_time + 150_ms;
    const auto kThirdStageEndTime = start_time + 300_ms;

    const auto kFirstStageBps = 10_mbps;
    const auto kSecondStageBps = 16_mbps;
    const auto kThirdStageBps = 8_mbps;
    //粒度是5ms
    auto cur_time = start_time;
    sender.set_bps(kFirstStageBps);
    while(cur_time &amp;lt; kFirstStageEndTime){
        auto packets = sender.send(cur_time);
        forwarder.recive(packets); 
        auto packets_f = forwarder.forward(cur_time);
        reciver.recive(packets_f, cur_time);
        cur_time = cur_time + 2_ms; //2ms处理间隔(尽量小,来模拟&quot;时时刻刻&quot;都在处理)
    }
    sender.set_bps(kSecondStageBps);
    while(cur_time &amp;lt; kSecondStageEndTime){
        auto packets = sender.send(cur_time);
        forwarder.recive(packets); 
        auto packets_f = forwarder.forward(cur_time);
        reciver.recive(packets_f, cur_time);
        cur_time = cur_time + 2_ms;
    }
    sender.set_bps(kThirdStageBps);
    while(cur_time &amp;lt; kThirdStageEndTime){
        auto packets = sender.send(cur_time);
        forwarder.recive(packets); 
        auto packets_f = forwarder.forward(cur_time);
        reciver.recive(packets_f, cur_time);
        cur_time = cur_time + 2_ms;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以时间t为横坐标，当前延迟梯度的累计和m(t)为纵坐标:
&lt;img src=&quot;../material/GccTrendingLineFilter/trendingChange.png&quot; alt=&quot;统计图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;变化方向&quot;&gt;变化方向&lt;/h3&gt;

&lt;p&gt;对上图中的&lt;strong&gt;“曲线(实际情况中应该是曲线)”&lt;/strong&gt;求切线:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;斜率&amp;gt;0，转发设备中的缓冲队列在增大，&lt;strong&gt;如果继续保持这个速度，情况会不断恶化&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;斜率&amp;lt;0，转发设备中的缓冲队列在减小，&lt;strong&gt;如果继续保持这个速度，情况会不断改善&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线性回归&quot;&gt;线性回归&lt;/h3&gt;

&lt;p&gt;TrendingLine模块的任务就是，根据历史的数据(时间和延迟梯度和)，计算当前一小段时间内的”斜率”，也就是”变化方向”，用于给速度控制模块参考信息。&lt;/p&gt;

&lt;p&gt;线性回归过程主要解决的就是如何通过样本来获取最佳的拟合线。最常用的方法便是最小二乘法，它是一种数学优化技术，它通过最小化误差的平方和寻找数据的最佳函数匹配。&lt;/p&gt;

&lt;h4 id=&quot;最小二乘法&quot;&gt;最小二乘法&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../material/GccTrendingLineFilter/linear_regresion.png&quot; alt=&quot;linear_regresion&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代码实现&quot;&gt;代码实现&lt;/h4&gt;

&lt;p&gt;计算延迟梯度时，以5ms为间隔，对达到的数据进行分组(5ms内达到的数据为一组)，论文中是以一帧为间隔。webrtc中的代码不太好懂，我自己的实现(可能也不太好懂)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// 对每一个到达的数据进行统计
void TrendingLineFilter::incoming_packet_feedback(int64_t send_time,
        int64_t recive_time,size_t size)
{
    (void) size;
    if(common::TimeDelta(send_time - cur_group_.first_packet_send_time) &amp;gt; kSampleGroupInterval
            &amp;amp;&amp;amp; cur_group_.initialized()){  //新的一组
        do{
            if(!prev_group_.initialized()){
                break;
            }
            //计算一组值
            assert(cur_group_.first_packet_send_time &amp;gt; 
                    prev_group_.first_packet_send_time);
            assert(cur_group_.last_packet_recive_time &amp;gt; 
                    prev_group_.last_packet_recive_time);
            int64_t send_time_delta = cur_group_.first_packet_send_time 
                            - prev_group_.first_packet_send_time;
            int64_t recive_time_delta = cur_group_.last_packet_recive_time 
                            - prev_group_.last_packet_recive_time;

            int64_t delta_us = recive_time_delta - send_time_delta;

            insert_new_sample_and_update(delta_us,recive_time);
            detect(send_time_delta,recive_time);
            //...
        } while(false);
        prev_group_ = cur_group_;
        cur_group_ = TimestampGroup();
    }
    if(cur_group_.first_packet_send_time &amp;gt; 0){
        cur_group_.first_packet_send_time = std::min(cur_group_.first_packet_send_time, send_time);
    }
    else{
        cur_group_.first_packet_send_time = send_time;
    }
    cur_group_.last_packet_recive_time = std::max(cur_group_.last_packet_recive_time, recive_time);
    
}

void TrendingLineFilter::insert_new_sample_and_update(int64_t delta_us,int64_t complete_time_us)
{
    const int64_t delta_ms = std::lround(delta_us * 1.0 / 1000);
    int64_t complete_time_ms = std::lround(complete_time_us * 1.0 / 1000);
    first_arrive_time_ms_ = std::min(first_arrive_time_ms_, complete_time_ms);
    acc_delay_ += delta_ms;
    num_delay_delta_ ++;
    num_delay_delta_ = std::min&amp;lt;int64_t&amp;gt;(num_delay_delta_,1000);
    smoothed_delay_ =  smooth_coeff_ * smoothed_delay_ + (1 - smooth_coeff_) * acc_delay_;
    sample_points_.push_back(
            {   //由于是&quot;差&quot;，所以每一组数据都不会非常大，数值不会溢出，可以放心用于后续的数学计算
        complete_time_ms - first_arrive_time_ms_,
                smoothed_delay_
            });
    if(sample_points_.size() &amp;gt;= window_size_) {
        /**@explain:
         *  trend 可以认为是对当前网络状态的一个反映 : (send_rate - capacity) / capacity;
         *  trend &amp;gt; 0,网络的排队延迟正在朝着增大的方向发展
         *  trend &amp;lt; 0,网络的排队延迟正在朝..减少........
         *  trend = 0,没有变化
         */
        cur_trend_ = linear_regresion();
        sample_points_.pop_front();
    }
}
// 根据数据公式进行计算
double TrendingLineFilter::linear_regresion()
{
    assert(sample_points_.size() == window_size_);
    double trend = cur_trend_;
    double sum_x = 0;
    double sum_y = 0;
    //TODO: 在求平均数这个事情上可以有优化的措施
    //但是意义并不大
    for (const auto&amp;amp; point : sample_points_) {
        sum_x += point.x;
        sum_y += point.y;
    }
    double x_avg = sum_x / sample_points_.size();
    double y_avg = sum_y / sample_points_.size();
    double numerator = 0;
    double denominator = 0;
    for (const auto&amp;amp; point : sample_points_) {
        numerator += (point.x - x_avg) * (point.y - y_avg);
        denominator += (point.x - x_avg) * (point.x - x_avg);
    }
    //TODO:C++17 的optional 可以用在分母为0的处理
    if( denominator != 0 ){
        trend = numerator / denominator;
    }
    return trend;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;联系我&quot;&gt;联系我&lt;/h3&gt;

&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Jun 2019 10:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//GccTrendlineFilter/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//GccTrendlineFilter/</guid>
        
        
        <category>network,gcc,udp</category>
        
      </item>
    
      <item>
        <title>总结c++中的cast</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;此文算是一个notes，总结一下C++中的各类cast用法和原理。&lt;/p&gt;
&lt;h3 id=&quot;static_cast&quot;&gt;static_cast&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;总结:反转一个定义良好的隐式类型转换&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;static_cast 执行关联类型之间的转换，比如一种指针类型向同一个类层次中其它指针类型的转换，或者整数类型向枚举类型的转换，或者浮点类型向整数类型的转换。它还能执行构造函数和转换运算符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;同一类层次&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class B{
};
class D : public B{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B和D就叫做同一个类层次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;char* ptr_c = nullptr;
int* ptr_i = static_cast&amp;lt;int*&amp;gt;(ptr_c); //编译失败
B* ptr_b = new B();
D* ptr_d = ptr_b; //编译失败
D* ptr_d = static_cast&amp;lt;D*&amp;gt;(ptr_b); //fine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，down_cast是没有任何保证的，程序员必须明白会发生什么事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;整数类型向枚举类型的转换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;enum class E : uint8_t{
    kValue = 1
};
uint8_t v = E::kValue ; //编译失败
uint8_t v = static_cast&amp;lt;uint8_t&amp;gt;(E::kValue); //fine
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;const_cast&quot;&gt;const_cast&lt;/h3&gt;
&lt;p&gt;const_cast&lt;type&gt;(expression)&lt;/type&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;参与转换的类型仅在const修饰符及volatile修饰符上有所区别&lt;/strong&gt;，除此以外new_type和expression的类型是一样。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;常量指针被转化成非常量的指针，并且仍然指向原来的对象。&lt;/li&gt;
    &lt;li&gt;常量引用被转化成非常量的引用，并且仍然指向原来的对象。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/h3&gt;
&lt;p&gt;dynamic_cast&amp;lt;type*&amp;gt;(e) 执行指针或者引用向类层次体系的类型转换，并执行运行时检查。&lt;/p&gt;

&lt;p&gt;不管是向上或者向下或者向左右都可以调用dynamic_cast。&lt;/p&gt;

&lt;p&gt;对于upcast，可以但没必要，向上塑性直接写就完事儿了。&lt;/p&gt;

&lt;h3 id=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/h3&gt;
&lt;p&gt;reinterpret_cast&lt;type&gt;(expression)&lt;/type&gt;&lt;/p&gt;

&lt;p&gt;这玩意就用的比较少了，和static_cast不一样，只有以下情况可以使用reinterpret_cast:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.表达式是整形、枚举、指针、或者成员指针&lt;/li&gt;
  &lt;li&gt;2.指针和整形互转&lt;/li&gt;
  &lt;li&gt;3.T1* 可以和 T2* 互转&lt;/li&gt;
  &lt;li&gt;4.T1左值可以转化为T2引用&lt;/li&gt;
  &lt;li&gt;5.函数指针可以随便转，不用管类型。这里的函数指针包括类成员函数。
相对与static_cast的区别，有以下一个例子:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class A {
    public:
    int m_a;
};
class B {
    public:
    int m_b;
};
class C : public A, public B {};

C c;
printf(&quot;%p, %p, %p&quot;, &amp;amp;c, reinterpret_cast&amp;lt;B*&amp;gt;(&amp;amp;c), static_cast &amp;lt;B*&amp;gt;(&amp;amp;c));
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量，并将之转换到正确的地址（c里面有m_a,m_b，转换为B*指针后指到m_b处），而reinterpret_cast却不会做这一层转换。因此, 你需要谨慎使用 reinterpret_cast。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;static_pointer_cast&quot;&gt;static_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;dynamic_pointer_cast&quot;&gt;dynamic_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;const_pointer_cast&quot;&gt;const_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;reinterpret_cast-1&quot;&gt;reinterpret_cast&lt;/h3&gt;

&lt;p&gt;总结上述4个:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; static_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    auto p = static_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get());
    return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
}

template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; dynamic_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    if (auto p = dynamic_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get())) {
        return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
    } else {
        return std::shared_ptr&amp;lt;T&amp;gt;();
    }
}

template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; const_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    auto p = const_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get());
    return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
}

template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; reinterpret_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    auto p = reinterpret_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get());
    return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 11 Mar 2019 12:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//cppcastall/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//cppcastall/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>字符串编码</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;一直以来，字符串编码总是我摸不着头脑。对待字符串编码问题的策略也是简单粗暴，直接规避：一律使用utf-8。但是，猿在码界漂，哪能不挨刀。今天就总结一下字符串编码问题。&lt;/p&gt;
&lt;h3 id=&quot;编码类型介绍&quot;&gt;编码类型介绍&lt;/h3&gt;
&lt;h4 id=&quot;ascii&quot;&gt;ascii&lt;/h4&gt;
&lt;p&gt;编码格式花样很多。由于计算机是老美发明的，因此，最早只有127个字符被编码到计算机中，着127个字符被称为ascii编码集。由于ascii字符集只有127个字符，故只要一个字节就可以表示。&lt;/p&gt;

&lt;h4 id=&quot;else&quot;&gt;else&lt;/h4&gt;
&lt;p&gt;但是，世界上那么多国家、那么多语言，全世界人民都想体验一把先进文化，于是八仙过海，各显神通，日本把日文编码到Shift-jis中，韩国把韩文编码到Euc-kr中。我们国家陆续有gb2312、gbk、gb18030，后者都是对前者的扩展。拿我们汉字举例，汉字有成千上万个，所以一个字节表示不了那么多的汉字，所以就需要多个字节(2个或3个)来表示。&lt;/p&gt;
&lt;h4 id=&quot;unicode&quot;&gt;unicode&lt;/h4&gt;
&lt;p&gt;大家要是没有一套统一的编码格式的话，还怎么促进文化的交流、各国码农感情的培养。于是，unicode应运而生，unicode把所有语言都统一到一套编码中，这样大家就可以顺畅的交流了。为了表示那么多的语言，unicode也只能采用多字节表示法，就是一个字符用多个字节的数据表示。&lt;/p&gt;

&lt;p&gt;于是，新的问题又出现了。对于大部分西方国家，他们使用的英语，一个字节就可以表示一个字符。如果使用unicode，那岂不是很浪费空间。于是又有人想出来了一种更佳妙的方式：对unicode继续编码。（可以理解成对unicode压缩编码）&lt;/p&gt;

&lt;p&gt;也就说，utf-8,utf-16,utf-32是在unicode基础上，对unicode再次编码。&lt;/p&gt;

&lt;p&gt;以UTF-8来说：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ascii&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;unicode&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;00000000 01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01001110 00101101  11100100 10111000&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10101101&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这么多编码格式，大家的一个共同点就是：完全对ascii码兼容。也就是说ascii中的’a’，和gb2312中的’a’是同样的表示方法(假设是0x63)。&lt;/p&gt;

&lt;h3 id=&quot;实际环境&quot;&gt;实际环境&lt;/h3&gt;
&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;如果您是在linux上开发，通常是碰不到这些问题的。(没错，我就是舔狗)&lt;/p&gt;

&lt;p&gt;在Linux上，系统默认就是utf-8格式。这是什么意思？&lt;/p&gt;

&lt;p&gt;举例来说，当你 “touch main.cpp” 这个文件就是采用的utf-8来编码里面的所有数据。
当你&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个pstr中的内容就会以utf-8格式存储。
当你:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;g++ main.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; a.out
&amp;amp; ./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;编译器会忠于你的文件编码格式，按此编码格式处理该源文件。pstr中的内容会被取出来放在内存中，并以utf-8格式输出在终端环境上。终端能不能正常显示，就看你的终端能不能支持utf-8。&lt;/p&gt;

&lt;p&gt;任何的字符串乱码问题，就是上面这三种中的某一个或多个编码格式不一样导致。&lt;/p&gt;
&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;在windows上，呵呵呵了。中文windows默认采用gb2312格式。&lt;/p&gt;

&lt;p&gt;举例来说。当你”新建一个文件”，这个文件通常是gb2312格式，如果这个文件只在本地使用，这时候通常是没问题的。&lt;/p&gt;

&lt;p&gt;但是当你因为某些原因需要使用在windows上使用”unicode”，问题就来了。
还是以上面main.cpp为例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.如果main.cpp为gb2312，用vs编译，pstr为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;2.如果main.cpp为纯unicode，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;3.如果main.cpp为utf-8(无bom)，用vs编译，pstr在内存里为utf-8格式，但是终端显示不了中文。&lt;/li&gt;
  &lt;li&gt;4.如果main.cpp为utf-8(bom)，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到了吧，vs的”睿智”。这个问题如果搭配上”wchar_t”，更加让人恼火。&lt;/p&gt;

&lt;p&gt;上面的测试可以采用如下程序：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%x,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将结果和各个编码表进行对照，既可得出结论。&lt;/p&gt;

&lt;p&gt;在unicode方面，对windows的批评滔滔不绝，”utf-8 everywhere”认为微软在字符串处理上误入歧途，因为他们比别的厂商更早做了决定。微软虽然有理由说，windows先于unicode问世。但是这么多年过去了，windows的API还是不完全支持unicode。&lt;/p&gt;

&lt;p&gt;windows不遵守基本法，也不是一天两天了，嘻嘻。&lt;/p&gt;

&lt;p&gt;关于如何在windows处理utf-8，以及对windwos的更多批评，可以从这篇文章起步: &lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt; “&lt;/p&gt;
&lt;h3 id=&quot;char与wchar_tstring与wstring&quot;&gt;char与wchar_t，string与wstring&lt;/h3&gt;
&lt;p&gt;如果您不幸遇到了string和wstring方便的困扰，恭喜您。&lt;/p&gt;

&lt;p&gt;首先，std::string 和 std::wstring都继承与std::basic_string。
只不过std::string的模板参数是char，std::wstring的模板参数是wchar_t。
在linux上，wchar_t占用4个字节，windows上则是占用2个字节。他们之间的差别，&lt;strong&gt;仅此而已。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你如果使用wstring存放字符串，Linux是没有啥问题的，采用utf-32编码wstring。&lt;/p&gt;

&lt;p&gt;但是如果是windows上，嘻嘻，问题又来了。假设在main.cpp中存放了一个std::wstring = “abc中文”,那么：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.a.cpp如果是gb2312格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;2.a.cpp如果是unicode格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;3.a.cpp如果是utf-8格式，wstring在内存中是ucs-2be格式。&lt;/li&gt;
  &lt;li&gt;4.a.cpp如果是utf-8-bom格式，wstring在内存中是unicode格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;您肯定还有一个疑惑，&lt;strong&gt;关于wstring和string之间的互相转换&lt;/strong&gt;。
那么，您需要确保你非常了解待转换的数据的格式，或者待转换数据仅来自本地。&lt;/p&gt;

&lt;p&gt;在windows上，windows有一个奇技淫巧：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WideCharToMultiByte系列API，通过参数设定你就可以获得你所希望的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见windows api说明，如何正确使用，请看： &lt;a href=&quot;https://stackoverflow.com/questions/215963/how-do-you-properly-use-widechartomultibyte&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，c++标准库也可以做到：std::locale、std::codecvt结合使用。&lt;/p&gt;

&lt;h3 id=&quot;帮组文档&quot;&gt;帮组文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/59522148&quot;&gt;潜谈C/C++编程中的字符编码转换&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/ybusad/blog/363139&quot;&gt;C++字符编码问题探究和中文乱码的产生&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;获得帮助&quot;&gt;获得帮助&lt;/h3&gt;
&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Nov 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//string-coding/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//string-coding/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>C++成员函数指针的大小</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;c中的函数指针假定在64位机器上&quot;&gt;c++中的函数指针(假定在64位机器上)&lt;/h3&gt;

&lt;p&gt;我们知道指针的大小恒定的,跟机器位数有关,32位机下,指针是4字节大小,64位机下指针是8字节大小.但是在C++中,有一个比较特殊的地方是C++的类成员函数
指针,它的大小是普通指针的2倍.先看一个实例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void foo(void)
{
}
class A{
public:
    void foo(){}
}

int main()
{
    void (*pfun)(void);
    pfun = foo;
    void (A::*pMfun)(void);
    pMfun = &amp;amp;A::foo;
    std::cout&amp;lt;&amp;lt;&quot;normal function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pfun)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&quot;member function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pMfun)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;normal &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:8
member &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;证明完毕.下面解释为什么会这样.&lt;/p&gt;
&lt;h3 id=&quot;this指针的调整&quot;&gt;this指针的调整&lt;/h3&gt;

&lt;p&gt;再看一个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class A{
public;
    void foo()
    {
        //假设我们需要在这里去使用数组a
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
private:
    int a[4];
};
class B{
public:
    void bar()
    { 
        //假设我们需要在这里去使用数组b
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
prviate:
    int b[4];
};
class C: public A,B{

};

int main()
{
    C c; 
    c.foo();
    c.bar();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addr of this:%x0x7ffd30f4ec00
addr of this:%x0x7ffd30f4ec10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候可以看到,传递给foo和bar函数的this指针是不一样的?为什么会不一样呢? 考虑一下函数中的注释.
所以调用类成员函数指针时,就需要将this指针进行调整,这个调整的信息在哪里?就在这个函数指针中,所以就需要另外的空间去存放这些信息,这也就是为什么类成员函数指针是16字节的原因,因为多出来的8字节,用于编译期的this指针调整.&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Jul 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</guid>
        
        
        <category>c++</category>
        
      </item>
    
  </channel>
</rss>
