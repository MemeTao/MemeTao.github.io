<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome my site</title>
    <description>中国计量大学本科 通信工程 在读(2017)
 
</description>
    <link>http://MemeTao.github.io//</link>
    <atom:link href="http://MemeTao.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 16 Apr 2019 15:29:26 +0800</pubDate>
    <lastBuildDate>Tue, 16 Apr 2019 15:29:26 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>总结c++中的cast</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;此文算是一个notes，总结一下C++中的各类cast用法和原理。&lt;/p&gt;

&lt;h3 id=&quot;static_cast&quot;&gt;static_cast&lt;/h3&gt;

&lt;h3 id=&quot;const_cast&quot;&gt;const_cast&lt;/h3&gt;

&lt;h3 id=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/h3&gt;

&lt;h3 id=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/h3&gt;

&lt;h3 id=&quot;static_pointer_cast&quot;&gt;static_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;dynamic_pointer_cast&quot;&gt;dynamic_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;const_pointer_cast&quot;&gt;const_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;reinterpret_cast-1&quot;&gt;reinterpret_cast&lt;/h3&gt;

</description>
        <pubDate>Mon, 11 Mar 2019 12:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//cppcastall/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//cppcastall/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>局域网下时间同步(精度100us)</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;本文介绍在&lt;strong&gt;非异常恶劣&lt;/strong&gt;的网络中，如何同步两台机器的本地时间，我们的目标是&lt;strong&gt;尽量(大概率上)&lt;/strong&gt;将时间同步的误差控制在0.1ms。&lt;/p&gt;

&lt;p&gt;众所周知，网络中存在time服务器，利用ntp协议可以将网络中主机的本地时间同步到1s的误差范围。对于正常应用，这个精度应该是够的。但是总存在一些特殊应用，它对时间的精度要求更高。在这种情况下，time服务已经不满足我们的需要了。&lt;/p&gt;

&lt;h3 id=&quot;基本方式&quot;&gt;基本方式&lt;/h3&gt;
&lt;p&gt;在ping模式下，机器A发送一个包，并记录发包时间t1，机器B收到Icmp包后发送ack包，机器A收到ack包后记录收包时间t2，t2减t1就被认为是rtt。&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Jan 2019 11:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//timesynchronize/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//timesynchronize/</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>2019学习计划</title>
        <description>&lt;hr /&gt;
&lt;h3 id=&quot;1linux-011源码4个月51前学完&quot;&gt;1.Linux 0.11源码(4个月,5.1前学完)&lt;/h3&gt;
&lt;p&gt;涉及A&amp;amp;TT汇编基础知识、内核早期源码、x86基础知识&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//studyplay_january/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//studyplay_january/</guid>
        
        
        <category>study</category>
        
        <category>plan</category>
        
      </item>
    
      <item>
        <title>AT&amp;T汇编摘记</title>
        <description>&lt;h3 id=&quot;0-寄存器&quot;&gt;0. 寄存器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通用寄存器&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;共有16个通用寄存器，如下图所示:
&lt;img src=&quot;../material/X86_64ASSEMBLY/general_register.png&quot; alt=&quot;generalRegister&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Segment Register&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;CS:存放程序在内存中的基地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;DS:数据段地址(.data?)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;«Linux 0.11完全注释»P90有关于这个的介绍&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指令指针寄存器(EIP)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;远跳转:在分段模式下，当跳转到另一个段中的指令时&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;短跳转:当跳转偏移量小于128字节时&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;近跳转:除1,2外的所有其它跳转
&lt;strong&gt;堆栈指针寄存器(ESP)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;0.指向栈顶&lt;/li&gt;
  &lt;li&gt;1.函数调用:通常和EBP一起配合使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-数据段&quot;&gt;1. 数据段&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数据段(.data),以及.bss段&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//code1
int main()
{
    return 0;
}
//code2
int a;
int main()
{
    return 0;
}
//code3
int a = 0;
int main()
{
    return 0;
}
int a = 1;
int main()
{
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;code1\2\3的text data bss大小一样，code4的data段比123多4字节，bss段比123少4字节。&lt;/p&gt;

&lt;p&gt;这说明：
&lt;em&gt;被显式初始化、且初值不为0的全局变量存放于.data段，为初始化的全局变量或者初始化为0的全局变量存放与.bss段。&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//code11
int main()
{
    return 0;
}
//code12
static int i;
int main()
{
    return 0;
}
//code13 
static int i = 0;
int main()
{
    return 0;
}
//code 14
static int i = 1;
int main()
{
    return 0;
}
//code 15
int main()
{
    static int i ;
    return 0;
}
//code 16
int main()
{
    static int i = 0;
    return 0;
}
//code 17
int main()
{
    static int i = 1;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对与static修饰的变量，从&lt;strong&gt;存放位置&lt;/strong&gt;看，和全局变量没有任何区别:不管在局部静态变量还是全局静态变量，都按照全局变量处理。
&lt;strong&gt;text 代码段&lt;/strong&gt;
没啥好说的。&lt;/p&gt;

&lt;p&gt;段寄存器CS和DS用于包含代码段和数据段的地址，CS + EIP（段中偏移）就可以获取指令码的地址。
这里不做详细的介绍，«Linux0.11»中介绍了段管理的具体细节。&lt;/p&gt;

&lt;h3 id=&quot;2-函数&quot;&gt;2. 函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;声明函数&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pushl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;movl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#code from here
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;movl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;popl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;堆栈情况:
&lt;img src=&quot;../material/X86_64ASSEMBLY/stack_overview.png&quot; alt=&quot;stackOverview&quot; /&gt;
解释：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当执行到bar(1,2)时，现将2,1参数压人堆栈然后将”return”语句的地址压入堆栈，但是为了避免在bar中出现push,pop等操作把返回地址给弄丢了，使用另外一个寄存器:ebp来存放’esp’的地址，当然还需要保存旧的ebp地址。所以函数的首部和尾部就长成了上述这样。(«汇编预言程序设计» P245)&lt;/p&gt;

&lt;p&gt;还剩最后一个问题，如果函数把任何数据都压入堆栈，ESP寄存器仍然指向局部变量被存放之前的位置，并且将覆盖这些变量。为了解决这个问题，需要在函数开始的位置预留一定数量的栈空间。&lt;/p&gt;

&lt;h3 id=&quot;3链接&quot;&gt;3.链接&lt;/h3&gt;
&lt;p&gt;一段程序包含.text .data .bss 段链接器会将所有的目标文件的这些段合并在一块。
&lt;img src=&quot;../material/X86_64ASSEMBLY/link_object.png&quot; alt=&quot;ldOverview&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//att_assembly_manaul/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//att_assembly_manaul/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Linux 0.11运行机制</title>
        <description>&lt;hr /&gt;

&lt;p&gt;这将是一个漫长的过程，终将解答我心中的疑惑….&lt;/p&gt;
&lt;h3 id=&quot;step-0-启动阶段&quot;&gt;step 0: 启动阶段&lt;/h3&gt;
&lt;h4 id=&quot;磁盘引导&quot;&gt;磁盘引导&lt;/h4&gt;
&lt;p&gt;PC加电后，BIOS将引导扇区加载到内存0x7C00处(为什么是这个地址?是个业内约定)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;引导扇区:

Boot sector(引导扇区)是所有存储介质上的第一个扇区，大小为512字节。主要分为三个部分，分别是:
* 1. MBR(master boot record,主引导记录) 445字节
* 2. DPT(disk partition table,磁盘分区表) 64字节
* 3. BRID(boot record ID 引导记录标示) 2字节
#### MBR 
主引导记录的作用是安装基本的引导加载程序(boot loader),在Linux中是grub。grub的主要功能是：
* 1. 提供菜单：用户可以选择不同的开机选项，这是多重引导的虫咬功能。
* 2. 载入内核文件: 直接指向可开机的程序区段来开始操作系统
* 3. 转交其它Loader: 将引导加载功能交给其它loader处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bootsect.s 是第一个被CPU执行的程序，这个程序先把自己从移动到0x90000处，接在吧磁盘中的setup.s弄到内存里来（具体的位置是0x920000)，然后把system模块移动到0x10000处，跳转到setup程序，setup.s程序又将system模块移动到内存起始地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bootsect.s,setup.s 为什么要移来移去的？

我们的目标是要将操作系统放到内存里去，最好的位置就是内存起始地址(0x0000)，但是在刚开始的时候，BIOS在那个内存起始处保存了中断向量和终端服务程序，所以在仍然需要用到BIOS功能之前我们不能直接将系统移动到那个地方去。

为什么是0x900000?

那时候system模块挺小的，0x0000000 ---- 0x900000 足够放置system模块代码。 

为什么是0x10000？

BIOS相关的的东西在 0x000000 --- 0x10000中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gdtldtrdt表&quot;&gt;gdt,ldt,rdt表&lt;/h3&gt;

&lt;p&gt;setup.s 做了一系列的操作中，最重要的当然是这三个表的初始化，设置好代码段、数据段后程序就可以跑起来了,具体的细节涉及到”X86保护模式以及编程”。setup.s调用head.s代码，执行完后内存映像如下：
&lt;img src=&quot;../material/Linux011/heads.png&quot; alt=&quot;head.s内存映像&quot; /&gt;
注：页表、描述符表等的初始化在head.s代码中&lt;/p&gt;

&lt;h3 id=&quot;内核初始化mainc程序&quot;&gt;内核初始化main.c程序&lt;/h3&gt;

&lt;h4 id=&quot;trap_init&quot;&gt;trap_init()&lt;/h4&gt;

&lt;p&gt;Linux0.11 用过门描述符在idt表中放置了各种异常处理函数(具体操作是traps.c:trap_inti())，包括：除0，段错误等。当异常发生的时候，根据idt表中的段选择符找到中断处理函数，执行相应的处理回调，以除0为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;
#首先进入中断处理(涉及各类寄存器的处理，具体原理要看&quot;X86保护模式及其编程&quot;)，执行asm.s中的&quot;divide_error&quot;:

divide_error:
	pushl $do_divide_error # 接下来被调用
no_error_code:
	xchgl %eax,(%esp)      #寄存器处理
	pushl %ebx
	pushl %ecx
	pushl %edx
    ...
    ...
    iret                  #返回后，CS:EIP 可能已经被改变

void do_divide_error(long esp, long error_code)
{
	die(&quot;divide error&quot;,esp,error_code);
}

static void die(char * str,long esp_ptr,long nr)
{
	long * esp = (long *) esp_ptr;
	int i;

	printk(&quot;%s: %04x\n\r&quot;,str,nr&amp;amp;0xffff);
	printk(&quot;EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n&quot;,
		esp[1],esp[0],esp[2],esp[4],esp[3]);
	printk(&quot;fs: %04x\n&quot;,_fs());
	printk(&quot;base: %p, limit: %p\n&quot;,get_base(current-&amp;gt;ldt[1]),get_limit(0x17));
	if (esp[4] == 0x17) {
		printk(&quot;Stack: &quot;);
		for (i=0;i&amp;lt;4;i++)
			printk(&quot;%p &quot;,get_seg_long(0x17,i+(long *)esp[3]));
		printk(&quot;\n&quot;);
	}
	str(i);
	printk(&quot;Pid: %d, process nr: %d\n\r&quot;,current-&amp;gt;pid,0xffff &amp;amp; i);
	for(i=0;i&amp;lt;10;i++)
		printk(&quot;%02x &quot;,0xff &amp;amp; get_seg_byte(esp[1],(i+(char *)esp[0])));
	printk(&quot;\n\r&quot;);
	do_exit(11);		/* play segment exception */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见默认的处理就是”打印出错地址，杀死当前进程”，然后重新调度起另一个进程(do_exit()中)。&lt;/p&gt;

&lt;h3 id=&quot;system_call&quot;&gt;system_call&lt;/h3&gt;

&lt;p&gt;系统调用是使用0x80中断，具体的原理是:在idt表中的第0x80(124)个索引中存放了一个DPL=3的陷进门(sched_init函数中)，所以用户态代码可以以特权级别3（DPL&amp;lt;=MIN(CPL,RPL))来访问这个陷进门。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set_system_gate(0x80,&amp;amp;system_call);

//dpl = 3 , 所以用户态代码可以通过这个门进入内核
//type = 15 陷阱门
#define set_system_gate(n,addr) \
	_set_gate(&amp;amp;idt[n],15,3,addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在system_call中根据系统调用号来决定调用哪一个系统调用函数，每个系统调用函数都存放在一个函数指针数组：sys_call_table中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;system_call:   
	cmpl $nr_system_calls-1,%eax
	ja bad_sys_call
	push %ds
	push %es
	push %fs
	pushl %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters
	pushl %ebx		# to the system call
	movl $0x10,%edx		# set up ds,es to kernel space
	mov %dx,%ds
	mov %dx,%es
	movl $0x17,%edx		# fs points to local data space
	mov %dx,%fs
	call sys_call_table(,%eax,4)  #执行具体的系统调用
	pushl %eax
	movl current,%eax
	cmpl $0,state(%eax)		# state
	jne reschedule
	cmpl $0,counter(%eax)		# counter
	je reschedule       # 重新调度
ret_from_system_call:   # 在这里处理了&quot;信号处理句柄&quot;
    ...
    ...
    iret                # 可见，先处理信号（如果有的话），在执行用户程序
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 11 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//os_study/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//os_study/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>ubuntu18.04上安装英伟达驱动</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;1查看显卡设备&quot;&gt;1.查看显卡设备&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#lspci &lt;/span&gt;
00:02.0 VGA compatible controller: Intel Corporation HD Graphics 620 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rev 02&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
302:00.0 3D controller: NVIDIA Corporation GM108M &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GeForce 940MX]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;一个是集成显卡,一个是独立显卡。点击”设置”-”详细信息”可以看到当前所使用的是哪一个显卡。&lt;/p&gt;

&lt;p&gt;查看推荐的显卡驱动&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# sudo ubuntu-drivers devices&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; /sys/devices/pci0000:00/0000:00:1c.0/0000:02:00.0 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;
modalias : pci:v000010DEd0000134Dsv000017AAsd00002246bc03sc02i00
vendor   : NVIDIA Corporation
model    : GM108M &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GeForce 940MX]
driver   : nvidia-driver-390 - distro non-free recommended
driver   : xserver-xorg-video-nouveau - distro free &lt;span class=&quot;nb&quot;&gt;builtin&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#sudo add-apt-repository ppa:graphics-drivers&lt;/span&gt;
Current long-lived branch release: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nvidia-410&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;410.66&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Old long-lived branch release: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nvidia-390&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;390.87&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;不知道为啥，找不到410&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#sudo apt update&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2安装&quot;&gt;2.安装&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;#sudo apt-get install nvidia-390   //安装390驱动&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#重启&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#重启完就ojbk了&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 09 Jan 2019 12:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//InstallNvidiaDriver/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//InstallNvidiaDriver/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>字符串编码</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;一直以来，字符串编码总是我摸不着头脑。对待字符串编码问题的策略也是简单粗暴，直接规避：一律使用utf-8。但是，猿在码界漂，哪能不挨刀。今天就总结一下字符串编码问题。&lt;/p&gt;
&lt;h3 id=&quot;编码类型介绍&quot;&gt;编码类型介绍&lt;/h3&gt;
&lt;h4 id=&quot;ascii&quot;&gt;ascii&lt;/h4&gt;
&lt;p&gt;编码格式花样很多。由于计算机是老美发明的，因此，最早只有127个字符被编码到计算机中，着127个字符被称为ascii编码集。由于ascii字符集只有127个字符，故只要一个字节就可以表示。&lt;/p&gt;

&lt;h4 id=&quot;else&quot;&gt;else&lt;/h4&gt;
&lt;p&gt;但是，世界上那么多国家、那么多语言，全世界人民都想体验一把先进文化，于是八仙过海，各显神通，日本把日文编码到Shift-jis中，韩国把韩文编码到Euc-kr中。我们国家陆续有gb2312、gbk、gb18030，后者都是对前者的扩展。拿我们汉字举例，汉字有成千上万个，所以一个字节表示不了那么多的汉字，所以就需要多个字节(2个或3个)来表示。&lt;/p&gt;
&lt;h4 id=&quot;unicode&quot;&gt;unicode&lt;/h4&gt;
&lt;p&gt;大家要是没有一套统一的编码格式的话，还怎么促进文化的交流、各国码农感情的培养。于是，unicode应运而生，unicode把所有语言都统一到一套编码中，这样大家就可以顺畅的交流了。为了表示那么多的语言，unicode也只能采用多字节表示法，就是一个字符用多个字节的数据表示。&lt;/p&gt;

&lt;p&gt;于是，新的问题又出现了。对于大部分西方国家，他们使用的英语，一个字节就可以表示一个字符。如果使用unicode，那岂不是很浪费空间。于是又有人想出来了一种更佳妙的方式：对unicode继续编码。（可以理解成对unicode压缩编码）&lt;/p&gt;

&lt;p&gt;也就说，utf-8,utf-16,utf-32是在unicode基础上，对unicode再次编码。&lt;/p&gt;

&lt;p&gt;以UTF-8来说：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ascii&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;unicode&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;00000000 01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01001110 00101101  11100100 10111000&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10101101&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这么多编码格式，大家的一个共同点就是：完全对ascii码兼容。也就是说ascii中的’a’，和gb2312中的’a’是同样的表示方法(假设是0x63)。&lt;/p&gt;

&lt;h3 id=&quot;实际环境&quot;&gt;实际环境&lt;/h3&gt;
&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;如果您是在linux上开发，通常是碰不到这些问题的。(没错，我就是舔狗)&lt;/p&gt;

&lt;p&gt;在Linux上，系统默认就是utf-8格式。这是什么意思？&lt;/p&gt;

&lt;p&gt;举例来说，当你 “touch main.cpp” 这个文件就是采用的utf-8来编码里面的所有数据。
当你&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个pstr中的内容就会以utf-8格式存储。
当你:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;g++ main.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; a.out
&amp;amp; ./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;编译器会忠于你的文件编码格式，按此编码格式处理该源文件。pstr中的内容会被取出来放在内存中，并以utf-8格式输出在终端环境上。终端能不能正常显示，就看你的终端能不能支持utf-8。&lt;/p&gt;

&lt;p&gt;任何的字符串乱码问题，就是上面这三种中的某一个或多个编码格式不一样导致。&lt;/p&gt;
&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;在windows上，呵呵呵了。中文windows默认采用gb2312格式。&lt;/p&gt;

&lt;p&gt;举例来说。当你”新建一个文件”，这个文件通常是gb2312格式，如果这个文件只在本地使用，这时候通常是没问题的。&lt;/p&gt;

&lt;p&gt;但是当你因为某些原因需要使用在windows上使用”unicode”，问题就来了。
还是以上面main.cpp为例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.如果main.cpp为gb2312，用vs编译，pstr为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;2.如果main.cpp为纯unicode，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;3.如果main.cpp为utf-8(无bom)，用vs编译，pstr在内存里为utf-8格式，但是终端显示不了中文。&lt;/li&gt;
  &lt;li&gt;4.如果main.cpp为utf-8(bom)，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到了吧，vs的”睿智”。这个问题如果搭配上”wchar_t”，更加让人恼火。&lt;/p&gt;

&lt;p&gt;上面的测试可以采用如下程序：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%x,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将结果和各个编码表进行对照，既可得出结论。&lt;/p&gt;

&lt;p&gt;在unicode方面，对windows的批评滔滔不绝，”utf-8 everywhere”认为微软在字符串处理上误入歧途，因为他们比别的厂商更早做了决定。微软虽然有理由说，windows先于unicode问世。但是这么多年过去了，windows的API还是不完全支持unicode。&lt;/p&gt;

&lt;p&gt;windows不遵守基本法，也不是一天两天了，嘻嘻。&lt;/p&gt;

&lt;p&gt;关于如何在windows处理utf-8，以及对windwos的更多批评，可以从这篇文章起步: &lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt; “&lt;/p&gt;
&lt;h3 id=&quot;char与wchar_tstring与wstring&quot;&gt;char与wchar_t，string与wstring&lt;/h3&gt;
&lt;p&gt;如果您不幸遇到了string和wstring方便的困扰，恭喜您。&lt;/p&gt;

&lt;p&gt;首先，std::string 和 std::wstring都继承与std::basic_string。
只不过std::string的模板参数是char，std::wstring的模板参数是wchar_t。
在linux上，wchar_t占用4个字节，windows上则是占用2个字节。他们之间的差别，&lt;strong&gt;仅此而已。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你如果使用wstring存放字符串，Linux是没有啥问题的，采用utf-32编码wstring。&lt;/p&gt;

&lt;p&gt;但是如果是windows上，嘻嘻，问题又来了。假设在main.cpp中存放了一个std::wstring = “abc中文”,那么：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.a.cpp如果是gb2312格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;2.a.cpp如果是unicode格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;3.a.cpp如果是utf-8格式，wstring在内存中是ucs-2be格式。&lt;/li&gt;
  &lt;li&gt;4.a.cpp如果是utf-8-bom格式，wstring在内存中是unicode格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;您肯定还有一个疑惑，&lt;strong&gt;关于wstring和string之间的互相转换&lt;/strong&gt;。
那么，您需要确保你非常了解待转换的数据的格式，或者待转换数据仅来自本地。&lt;/p&gt;

&lt;p&gt;在windows上，windows有一个奇技淫巧：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WideCharToMultiByte系列API，通过参数设定你就可以获得你所希望的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见windows api说明，如何正确使用，请看： &lt;a href=&quot;https://stackoverflow.com/questions/215963/how-do-you-properly-use-widechartomultibyte&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，c++标准库也可以做到：std::locale、std::codecvt结合使用。&lt;/p&gt;

&lt;h3 id=&quot;帮组文档&quot;&gt;帮组文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/59522148&quot;&gt;潜谈C/C++编程中的字符编码转换&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/ybusad/blog/363139&quot;&gt;C++字符编码问题探究和中文乱码的产生&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;获得帮助&quot;&gt;获得帮助&lt;/h3&gt;
&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Nov 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//string-coding/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//string-coding/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>C++成员函数指针的大小</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;c中的函数指针假定在64位机器上&quot;&gt;c++中的函数指针(假定在64位机器上)&lt;/h3&gt;

&lt;p&gt;我们知道指针的大小恒定的,跟机器位数有关,32位机下,指针是4字节大小,64位机下指针是8字节大小.但是在C++中,有一个比较特殊的地方是C++的类成员函数
指针,它的大小是普通指针的2倍.先看一个实例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void foo(void)
{
}
class A{
public:
    void foo(){}
}

int main()
{
    void (*pfun)(void);
    pfun = foo;
    void (A::*pMfun)(void);
    pMfun = &amp;amp;A::foo;
    std::cout&amp;lt;&amp;lt;&quot;normal function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pfun)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&quot;member function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pMfun)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;normal &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:8
member &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;证明完毕.下面解释为什么会这样.&lt;/p&gt;
&lt;h3 id=&quot;this指针的调整&quot;&gt;this指针的调整&lt;/h3&gt;

&lt;p&gt;再看一个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class A{
public;
    void foo()
    {
        //假设我们需要在这里去使用数组a
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
private:
    int a[4];
};
class B{
public:
    void bar()
    { 
        //假设我们需要在这里去使用数组b
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
prviate:
    int b[4];
};
class C: public A,B{

};

int main()
{
    C c; 
    c.foo();
    c.bar();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addr of this:%x0x7ffd30f4ec00
addr of this:%x0x7ffd30f4ec10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候可以看到,传递给foo和bar函数的this指针是不一样的?为什么会不一样呢? 考虑一下函数中的注释.
所以调用类成员函数指针时,就需要将this指针进行调整,这个调整的信息在哪里?就在这个函数指针中,所以就需要另外的空间去存放这些信息,这也就是为什么类成员函数指针是16字节的原因,因为多出来的8字节,用于编译期的this指针调整.&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Jul 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>Socket注意事项:非阻塞connect的返回值</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;问题引入&quot;&gt;问题引入：&lt;/h3&gt;
&lt;p&gt;为了测试1S内TCP服务器单线程能accept多少并发TCP连接，由于正常的TCP建立可能需要几十毫秒，所以客户端发起的连接应该是这样子的:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_NONBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//非阻塞connect
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;代码运行后，我发现connect()返回值一直是false，但是使用tcpdump抓包发现tcp三次握手正常，也就是说仅仅是connect函数的返回值不符合预期。&lt;/p&gt;

&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;我再一次翻开«UNP»，在书上发现：&lt;strong&gt;当在一个非阻塞的TCP套接字上调用connect时，将立即返回一个EINPROGRESS错误，不过已经发起的TCP三路握手继续进行&lt;/strong&gt;，
这样问题就清晰了，修改代码如下：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_INET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_NONBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//非阻塞connect
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EINPROGRESS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注:errno是线程安全的，每个线程都保留一份errno。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;纸上得来终觉浅，绝知此事需躬行&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Feb 2018 15:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//SocketConnect/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//SocketConnect/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>TCP四次挥手中，Poll返回了几次？</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;我在给多线程TCP服务器写被动关闭逻辑时遇到了一个疑问，Poll返回的时机是什么时候？TCP四次挥手能够引起几次Poll返回？&lt;/p&gt;
&lt;h3 id=&quot;如何引入的问题&quot;&gt;如何引入的问题&lt;/h3&gt;
&lt;p&gt;一般的服务器编程逻辑，一般是由客户端发起的主动关闭，服务端实行被动关闭。按正常的流程是这样的:对端发送FIN，服务端发送ACK，如果没有多余数据，随即再发送FIN分节，对端继续发送ACK便进入熟知的TIME_WAIT状态，等待2MSL时间后进入CLOSE状态，本次TCP连接顺利断开。依照这个模型，我们只要在fd上注册一个回调函数，等poll返回时，用read系统调用即可判断是正常数据还是FIN分节，很容易得到如下回调函数伪代码:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//对端发来信息
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//正常处理信息
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//说明对端发送了FIN分节
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;addTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//让其它空闲线程来处理这个连接的资源
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//发送FIN
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上述代码在实际的运行时，发生了错误，操作系统提示我一个关键词：&lt;strong&gt;double free&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;寻找症结&quot;&gt;寻找症结&lt;/h3&gt;

&lt;p&gt;根据提示:我猜测是某些资源释放了多次。在多次复现问题后，最终发现这个问题出现在TCP连接断开的时候。&lt;/p&gt;

&lt;p&gt;我用Linux下的NC工具模拟了客户端TCP连接，并用tcpdump试图分析出一点蛛丝马迹：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./TcpServer &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; 65500     //在本地65500端口启动服务器
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nc 127.0.0.1 65500       //连接到服务器65500端口
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;Ctrl-D                   //一段时间后，NC主动断开连接 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以下是tcpdump本地抓包结果：
&lt;img src=&quot;../material/POLL/tcpdump.png&quot; alt=&quot;TCPDUMP&quot; /&gt;
首先是TCP三次握手，随后等我键入Ctrl-D断开连接，TCP四次挥手也很正常(由于FIN分节携带了ACK，所以表现出来是3个报文),然后服务端依然奔溃，并提示double free!&lt;/p&gt;

&lt;p&gt;用netstat命令显示的TCP状态变化:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;protocol&lt;/th&gt;
      &lt;th&gt;port1&lt;/th&gt;
      &lt;th&gt;port2&lt;/th&gt;
      &lt;th&gt;status&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp&lt;/td&gt;
      &lt;td&gt;—65500—&lt;/td&gt;
      &lt;td&gt;—59580—&lt;/td&gt;
      &lt;td&gt;—–ESTABLISHED&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tcp&lt;/td&gt;
      &lt;td&gt;—59580—&lt;/td&gt;
      &lt;td&gt;—65500—&lt;/td&gt;
      &lt;td&gt;—–TIME_WAIT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明连接是正常建立，正常断开的，一切都很正常!看来是一场硬仗，得调试代码了，由于当前还没有加入日志模块，用gdb又好像有点小题大作，先用printf大法试一下再说，最终发现&lt;strong&gt;在TCP四次挥手中，read() = 0 返回了两次！&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;引起poll返回的事件&quot;&gt;引起poll返回的事件&lt;/h3&gt;

&lt;p&gt;根据我的代码结构，回调之前是poll，随即开始查资料，在《APUE》中发现，以下条件是引起poll返回的特定revent:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;有数据可读，专业的说法是：套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低潮限度的当前值。可以使用套接字选项SO_RCVLOWAT来设置低潮限度，对于TCP和UDP套接字，其值缺省为1&lt;/li&gt;
  &lt;li&gt;连接的读这一半关闭，也就是说接收了FIN的TCP连接。对这样的套接字的套接字将不阻塞且返回0（即文件结束符）&lt;/li&gt;
  &lt;li&gt;套接字是一个监听套接字且已完成的连接数为非0，即连接建立后可读&lt;/li&gt;
  &lt;li&gt;有一个套接字错误待处理。对这样的套接字的读操作将不阻塞且返回一个错误（-1），errno则设置成明确的错误条件。这些待处理的错误也可以通过指定套接口选项SO_ERROR调用getsockopt来取得并清除。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;«UNP»还有如下补充:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;所有TCP和UDP正规数据都被认为是普通数据&lt;/li&gt;
  &lt;li&gt;TCP的待外数据被认为是优先级带数据&lt;/li&gt;
  &lt;li&gt;当TCP连接的读半部关闭时(譬如收到一个对端的FIN)，也被认为是普通数据，随后的读操作将返回0&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;那客户端进入TIME_WAIT状态时发送的最后一次ACK是不是一次普通数据呢?&lt;/strong&gt;在这个情况下，没有其它什么事件能够引起poll返回了，很明显了，罪魁祸首就是&lt;strong&gt;TCP四次挥手的第四次ACK！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题的关键以及解决方案&quot;&gt;问题的关键以及解决方案&lt;/h3&gt;
&lt;p&gt;之所以会出现这样的问题，是由于我的代码执行顺序的问题，由于是多线程，一个线程close(fd)使得tcp发送FIN分节，理论上，再此之前我们就应该注销掉这个连接的资源了。而我的代码试图将资源释放这个问题推迟一些以便于处理当下更紧急的其它任务，所以在poll所关注的事件列表中还有这个连接所关注的事件，所以引起了这个问题。清楚了原因之后，立马找到了解决方案：我只要注销掉poll中的该事件对应的fd即可，依然可以使得资源释放稍后执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方案一：具体是在read()返回0，后随机注销掉该socket_fd的一切事件。伪代码描述如下:
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pollfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//如果不懂,请查阅struct pollfd
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;addTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//让其他线程来处理该连接的资源
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;方案二:一个TCP连接的所以资源自始自终都由某一个线程管理，不要转移fd。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我修改了代码，两种方案都可以达到预期目标，考虑代码结构的问题，我采用了方案二。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;解决了上述问题后，我反思自己:当初看APUE和UNP的时候对上述问题之所以没有留下深刻的印象，原因恐怕是没有实际情况作为参照。想起一句名句:&lt;strong&gt;纸上得来终觉浅，绝知此事需躬行&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Feb 2018 15:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//Poll/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//Poll/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
  </channel>
</rss>
