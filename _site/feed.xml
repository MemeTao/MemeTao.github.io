<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome my site</title>
    <description>中国计量大学本科 通信工程 在读(2017)
 
</description>
    <link>http://MemeTao.github.io//</link>
    <atom:link href="http://MemeTao.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 07 Apr 2021 11:08:34 +0800</pubDate>
    <lastBuildDate>Wed, 07 Apr 2021 11:08:34 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>lea和mov指令的真正区别</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;lea指令&quot;&gt;lea指令&lt;/h3&gt;

&lt;p&gt;lea指令的解释是:load effective address.&lt;/p&gt;

&lt;p&gt;网上有很多解释, 比如知乎高赞&lt;a href=&quot;https://www.zhihu.com/question/40720890/answer/110774673&quot;&gt;汇编语言中mov和lea的区别有哪些？&lt;/a&gt; :&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lea是“load effective address”的缩写，简单的说，

lea指令可以用来将一个内存地址直接赋给目的操作数，

例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，

而不是把ebx+8处的内存地址里的数据赋给eax。

而mov指令则恰恰相反，例如：mov eax,[ebx+8]

则是把内存地址为ebx+8处的数据赋给eax。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说的没错, 可是仍旧是没有解释&lt;strong&gt;为什么用mov就不行&lt;/strong&gt;, 比如:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lea eax, &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ebx+8]&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 将ebx+8这个值直接赋给eax
难道不等价与:
mov eax, ebx+8&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实,这才是&lt;strong&gt;初学者&lt;/strong&gt;真正想问的问题.&lt;/p&gt;

&lt;p&gt;原因也很搞笑: &lt;strong&gt;mov指令的源操作数不支持立即数.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面的例子中, “ebx + 8”是立即数.&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Apr 2021 08:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//leaVSmov/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//leaVSmov/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>X86汇编笔记</title>
        <description>&lt;hr /&gt;

&lt;p&gt;###notes&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在8086处理器上,如果要用寄存器来提供偏移地址,只能使用BX,si,di,bP,不能使用其它寄存器.以下指令是非法的: mov [ax], dl&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;8086处理器只支持以下几种基地址寄存器和变址寄存器的组合:[bx+si] [bx+di] [bp+si] [bp+di]&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;条件转移指令&quot;&gt;条件转移指令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;js  当SF == 1则跳转 , jns与之相反&lt;/li&gt;
  &lt;li&gt;jz  当zF == 1则跳转,  jnz与之相反&lt;/li&gt;
  &lt;li&gt;jo  当OF == 1则跳转,  jno与之相反&lt;/li&gt;
  &lt;li&gt;jc  当CF == 1则跳转,  jnc与之相反&lt;/li&gt;
  &lt;li&gt;jp  当PF == 1则跳转,  jnp与之相反&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常用指令&quot;&gt;常用指令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;movsb | movsw
```shell
DS:SI –&amp;gt; ES:DI
DF = 0 low-&amp;gt;high
DF = 1 high-&amp;gt;low&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;instruction ‘cld’ can clear df&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
* div
A / B. A是被除数, B是为除数.

被除数A默认存在AX中, 或者AX和DX中(DX存高x位)

如果除数是8位，那么除法的结果AL保存商，AH保存余数.

如果除数16位，那么除法的结果 AX保存商，DX保存余数。

* cli &amp;amp;&amp;amp; sti 清除和设置IF(中断标志位)

### ret
* ret 弹栈到IP寄存器 
* retf 弹栈到IP,再弹栈到CS
* iret 弹栈到IP,再弹栈到CS,再弹栈到FLAGS

### call 指令

call 指令有三种形式:

第一种是16位相对近调用, 近调用的意思是被调用的目标过程位于当前代码段内,而非另一个不同的代码段,所以只需要得到偏移地址即可.

16位相对近调用是三字节指令, 操作码为0xE8. 在指令执行阶段, 处理器看到操作码0xE8, 就知道它应当调用一个过程. 于是,它用指令指针寄存器IP的当前内容加上指令中的操作数, 再加上3, 得到一个新的偏移地址. 接着将IP的原有内容压入栈. 最后,用刚才的偏移地址取代IP原油的内容. 这直接导致处理器的执行流程转移到目标位置处.

第二种是16位间接绝对近调用, 这种调用也是近调用, 只能调用当前代码段内的过程, 指令中的操作数不是偏移量, 而是被调用过程的真实偏移地址, 故称绝对地址. 这个地址不是直接出现在指令中,而是由16位的通用寄存器或者16位的内存单元简介给出. 

第三种是16位直接绝对远调用, 调用另一个代码段内的过程. 
比如: 
```shell
call 0x20000:0x0030
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果被调用过程处于当前代码段, 也没关系.&lt;/p&gt;

&lt;p&gt;第四种是16位间接绝对远调用, 这也属于段间调用,被调用过程属于另一个代码段. 比如:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;call far &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0x2000]
call far &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;bx]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;间接远调用必须使用&lt;strong&gt;far&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;中断&quot;&gt;中断&lt;/h3&gt;

&lt;p&gt;实模式下,处理器要求中断向量表需要存放在物理地址0x00000-&amp;gt;0x003ff,同1k的空间内,共256个中断,每个中断向量4个字节.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x00000 ... -&amp;gt; ....0x003ff
---------------------------------------------
偏移地址(2字节) | 段地址(2字节)    | 偏移地址..
---------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 12 Dec 2020 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//x84-assembly/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//x84-assembly/</guid>
        
        
        <category>assembly</category>
        
      </item>
    
      <item>
        <title>webrtc带宽预测中的Probe（探测）模块</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;probe&quot;&gt;Probe&lt;/h3&gt;
&lt;p&gt;webrtc使用gcc（google congestion control）来估计带宽，控制当前的发送速度。gcc中基于丢包和基于延迟的算法有个特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.能迅速响应带宽的衰减&lt;/li&gt;
  &lt;li&gt;2.不能迅速响应带宽的增加&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个例子，如果当前带宽是20mbps，由于其它因素，带宽骤降至15mbps，gcc能快速的给出over-using信号(rtt为10ms环境下，响应速度是100-200ms)。&lt;/p&gt;

&lt;p&gt;如果当前带宽是20mbps，由于其它因素，带宽升至了25mbps，依赖gcc自身的调整的话需要几十秒的时间（加性增减性乘的效果）。&lt;/p&gt;

&lt;p&gt;由于以上的原因，如果从0bps开始运行gcc算法（纯算法本身），要达到一定的带宽需要太长的时间。&lt;/p&gt;

&lt;p&gt;webrtc中有一个用来在起始阶段（或周期性）迅速探测到当前带宽的措施—就是Probe模块，和TCP的慢启动比较像啦！&lt;/p&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;
&lt;p&gt;Probe的原理简单说起来就是这样的：发送端以一定的速度发送数据包，同时记录这些数据包的发送时间、序列号（全局唯一）、探测组的id.&lt;/p&gt;

&lt;p&gt;接收端每过一段时间（50-150ms）会反馈数据包的到达时间，就像这样：
&lt;img src=&quot;../material/WebrtcProbe/1.png&quot; alt=&quot;probeExample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;s_t表示发送时间、r_t标识接受时间，这样我们就知道了发送速度、接收速度:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//发送端发送这些数据包的时间间隔
common::TimeDelta send_interval = common::TimeDelta(state.last_send - state.first_send);
//接收端接收这些数据包的时间间隔
common::TimeDelta recive_interval = common::TimeDelta(state.last_recive - state.first_recive);
//发送的字节数(已发送的字节减去最后一个数据包的字节，不难理解吧?)
size_t size_send = state.size_total_sent - state.size_last_sent;
//接收端收到的字节数(已接收的字节减去第一个数据包的字节，不难理解吧?)
size_t size_recive = state.size_total_recived - state.size_first_recived;
//从而就得到了双方的速度
common::DataRate send_bps = 1_bps * (size_send * 8 / ( send_interval / 1_sec));
common::DataRate receive_bps = 1_bps * (size_recive * 8 / ( recive_interval / 1_sec));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们定义S1为发送速度，R1为接收速度，那么可以认定当前的网络带宽至少是min(S1,R1)。
在这里涉及到几个问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如何控制发送端的速度&lt;/li&gt;
  &lt;li&gt;探测包的大小如果设置才会比较合理&lt;/li&gt;
  &lt;li&gt;探测应该持续多久，尽可能的避免对正常数据的影响&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;控制探测速度包大小探测时长&quot;&gt;控制探测速度、包大小、探测时长&lt;/h3&gt;
&lt;p&gt;webrtc中探测包是通过一个定时器来控制速度的。&lt;/p&gt;

&lt;p&gt;假设我们需要探测的目标速度是10mbps，探测时间是10ms，&lt;/p&gt;

&lt;p&gt;那么我们总共需要发送的所有探测包的总大小 total_bytes = 10mbps * 15ms  / 8 ;&lt;/p&gt;

&lt;p&gt;第一个探测包的大小取值为 bytes1 = 10_mbps * 1_ms / 8，立即发送。
为了控制速度，我们需要考虑第二个探测包的发送时间，假设是dt时间后发送，计算dt:&lt;/p&gt;

&lt;p&gt;dt = sent_bytes * 8 /  1_mbps;&lt;/p&gt;

&lt;p&gt;意思就是已发送比特数 除以 目标码率，在dt的时间后发送第二个探测包，这样我们就精确地控制了发送速度就是我们希望的速度。&lt;/p&gt;

&lt;p&gt;以这种方式发送数据包，直到”已发送字节”大于等于total_bytes，该轮探测结束。&lt;/p&gt;

&lt;p&gt;上述中15ms就是探测需要持续的时间(可以自定义)，bytes1就是探测包的大小(通过修改”1_ms”可以自定义大小)&lt;/p&gt;

&lt;p&gt;通过一定的手段，我们可以将正常数据流上的数据包变为探测包，减少对正常数据流的影响。&lt;/p&gt;

&lt;p&gt;探测一般都是已当前速度的几倍去发送数据，所以必不可免的会影响当前的数据流，可以修改”15_ms”来自定义探测时长。&lt;/p&gt;

&lt;h3 id=&quot;乘性探测&quot;&gt;乘性探测&lt;/h3&gt;

&lt;p&gt;为了快速的探测到实际带宽的大致值，使用乘性探测。&lt;/p&gt;

&lt;p&gt;举个例子，假设起始速度设置为450kbps，那么探测速度就设置为900kbps，如果探测结果在900kbps * 0.7 = 630kbps以上，继续向上探测，探测速度是1.8mbps，如果第二次探测结果在1.8mbps * 0.7以上，继续向上探测，探测速度是3.6mbps…..直到某一个探测结果不符合 “0.7以上”，那么就判定链路带宽应该在此次探测结果附近。&lt;/p&gt;

&lt;p&gt;然后，以这个速度发送数据流，在这个基础上运行gcc算法，通过延迟梯度和丢包来控制发送码率。&lt;/p&gt;

&lt;h3 id=&quot;实际情况&quot;&gt;实际情况&lt;/h3&gt;

&lt;p&gt;在我的实现中。在rtt 10ms的环境下，可以立刻探测到带宽上限。
运行日志如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;probe successful,send speed:892.845kbps,receive speed:898.797kbps
probe successful,send speed:888.780kbps,receive speed:891.707kbps
probe successful,send speed:1.771mbps,receive speed:1.628mbps
probe successful,send speed:1.777mbps,receive speed:2.214mbps
probe successful,send speed:3.358mbps,receive speed:3.337mbps
probe successful,send speed:3.521mbps,receive speed:3.591mbps
...
probe successful,send speed:30.376mbps,receive speed:31.149mbps
probe successful,send speed:59.897mbps,receive speed:45.238mbps &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;达到带宽上限&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;则认为当前带宽的上限是45.238mbps(我通过tc命令设置的带宽就是45mbps，探测结果非常的准)&lt;/p&gt;

&lt;p&gt;从300kbps的起始速度上升到45mbps，用时800ms。&lt;/p&gt;

&lt;p&gt;在实际环境中，webrtc就是通过该机制在起始阶段迅速的”跳跃”到一个合适的码率上。&lt;/p&gt;

&lt;h3 id=&quot;解答&quot;&gt;解答&lt;/h3&gt;
&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Aug 2019 09:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//gcc_testing/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//gcc_testing/</guid>
        
        
        <category>network</category>
        
        <category>program</category>
        
      </item>
    
      <item>
        <title>enable_shared_from_this 实现机制</title>
        <description>&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;template&amp;lt;typename T&amp;gt;
class shared_ptr{
public:
    shared_ptr&amp;lt;T&amp;gt;(T* t)
    {
        set_ptr(this,t);
    }
};

template&amp;lt;typename T&amp;gt;
class enable_shared_from_this{
public:
    shared_ptr&amp;lt;T&amp;gt; shared_from_this(){
        //if sp_ not null
        return sp_;
    }
private:
    shared_ptr&amp;lt;T&amp;gt; sp_; //FIXME:weak_ptr
};

template&amp;lt;typename T&amp;gt;
void set_ptr(shared_ptr&amp;lt;T&amp;gt; t, enable_shared_from_this&amp;lt;T&amp;gt;* e)
{
    e-&amp;gt;set_ptr(t);
}

void set_ptr(...)
{
    //do nothing
}

class t: public enable_shared_from_this&amp;lt;t&amp;gt;{
public:
    t() = default;
};

&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 16 Jul 2019 09:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//sharedptrTheory/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//sharedptrTheory/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>Google拥塞控制算法--TrendingLine滤波器</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;延迟梯度&quot;&gt;延迟梯度&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../material/GccTrendingLineFilter/gradient.png&quot; alt=&quot;延迟梯度&quot; /&gt;
左边的Tx表示发送时间，右边的tx表示接收时间。&lt;/p&gt;

&lt;p&gt;延迟梯度的计算公式就是： gt(i) = (t(i) - t(i-1)) - (T(i) - T(i-1))，实际上就是发送间隔和接收间隔的差值。&lt;/p&gt;

&lt;p&gt;网络状态良好的情况下，这个值为0，当网络状态变差(发送端速度不变，接收端速度下降)，这个值为正。&lt;/p&gt;

&lt;p&gt;举个例子：发送端以1mbps的速度发送(每1ms发送1kb数据)，接收端的带宽仅有0.5mbsp，如下图:
&lt;img src=&quot;../material/GccTrendingLineFilter/1mbpssender_0.5mbpsreciver.png&quot; alt=&quot;1mbps0.5mbps&quot; /&gt;
从第一个1kb到第二个1kb，发送端用时1ms，而接收端需要2ms，梯度= 2 -1 = 1ms。观测”延迟梯度”的值，就可以发现发送端和接收端的带宽不对等，需要改变一方的速度。&lt;/p&gt;

&lt;p&gt;考虑下面这一种情况：
&lt;img src=&quot;../material/GccTrendingLineFilter/networking.png&quot; alt=&quot;networking&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发送端与交换机之间的带宽是30mbps，接收端与交换机之间的带宽是10mbps。当发送端以10mbps的速度发送数据时，不考虑其它因素的影响，假设传播时延是10ms，那么任何数据包在10ms内就可以均匀到达接收端。&lt;/p&gt;

&lt;p&gt;当发送端以大于10mbps的速度发送数据时，由于接收端的网络设备的处理能力只有10mbps，会将无法及时转发的流量缓冲在出口队列中。&lt;/p&gt;

&lt;p&gt;模拟这下这种情况：发送端以10mbps的速度发送数据，维持100ms，提高速度到16mbps，维持150ms，下降速度到8mbps，并一直保持这个速度。假设发送端发送的单个报文长度为10k bit。&lt;/p&gt;

&lt;p&gt;前100ms内，接收端的带宽足够，不会有交换机缓冲。接下来的150ms，发送端速度大于接收端的带宽，有一半数据会被缓冲在交换机的队列中，队列长度不断增大，直至丢包。随后发送端速度下降到5mbps，队列中的数据又被不断抽出，直至恢复正常。&lt;/p&gt;

&lt;p&gt;用以下代码对上述情况进行简单的模拟:&lt;/p&gt;

&lt;h4 id=&quot;发送端&quot;&gt;发送端&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;std::vector&amp;lt;Packet&amp;gt; BitSender::send(common::Timestamp at_time)
{
    using namespace common::rate;
    using namespace common::time_interval;
    //初始化
    if(!last_sent_time_.is_valid()){
        last_sent_time_ = at_time;
    }

    size_t bits_will_send = 0;
    std::vector&amp;lt;Packet&amp;gt; packets; 
    bits_will_send = static_cast&amp;lt;size_t&amp;gt;(bps_.value() * 
            ((at_time - last_sent_time_) / 1_sec));
    bits_sent_ += bits_will_send;
    size_t bits_reamin = bits_will_send;
    //向上取整
    long n = std::lround(bits_reamin * 1.0 / kPacketSize);
    for(int i = 0 ; i &amp;lt; n ; i++)
    {
        Packet packet;
        packet.size = kPacketSize;
        packet.send_time = at_time;
        packets.push_back(packet);
    }
    last_sent_time_ = at_time;
    return packets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;转发端&quot;&gt;转发端&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//接受发送端的数据，放到队列中
void BitForwarder::recive(std::vector&amp;lt;Packet&amp;gt;&amp;amp; packets)
{
    for(auto&amp;amp; packet : packets)
    {
        packet.delay = packet.delay + 5_ms; //发送端-&amp;gt;转发端  传输时延
        fifo_.push(packet);
    }
}
//发送队列中的数据
std::vector&amp;lt;Packet&amp;gt; BitForwarder::forward(common::Timestamp at_time)
{
    size_t bits_will_forward = 0;
    if(!last_forwarded_time_.is_valid()){
        last_forwarded_time_ = at_time;
    }
    std::vector&amp;lt;Packet&amp;gt; forward_packets;
    bits_will_forward = static_cast&amp;lt;size_t&amp;gt;(bps_.value() *
            ((at_time - last_forwarded_time_) / 1_sec));
    bits_forwarded_ += bits_will_forward;
    size_t bits_remain = bits_will_forward;
    while(bits_remain &amp;amp;&amp;amp; fifo_.size()){
        if(fifo_.front().size &amp;lt;= bits_remain){
            forward_packets.push_back(fifo_.front());
            bits_remain -= fifo_.front().size;
            fifo_.pop();
        }else{
            break;
        }
    }
    last_forwarded_time_ = at_time;
    return forward_packets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;接收端&quot;&gt;接收端&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void BitReciver::recive(std::vector&amp;lt;Packet&amp;gt;&amp;amp; packets,
        common::Timestamp at_time)
{
    for(auto&amp;amp; packet : packets){
        packet.delay = packet.delay + 5_ms;  //转发端-&amp;gt;接收端 传输时延
        packet.recive_time = at_time;
    }
    record(packets); //对每个包的发送、接收时间进行记录
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;主函数&quot;&gt;主函数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;int main()
{
    BitSender sender(0_mbps);
    BitReciver reciver(10_mbps);
    BitForwarder forwarder(reciver.bps());

    const auto start_time = common::Timestamp::now();
    const auto kFirstStageEndTime = start_time + 100_ms;
    const auto kSecondStageEndTime = start_time + 150_ms;
    const auto kThirdStageEndTime = start_time + 300_ms;

    const auto kFirstStageBps = 10_mbps;
    const auto kSecondStageBps = 16_mbps;
    const auto kThirdStageBps = 8_mbps;
    //粒度是5ms
    auto cur_time = start_time;
    sender.set_bps(kFirstStageBps);
    while(cur_time &amp;lt; kFirstStageEndTime){
        auto packets = sender.send(cur_time);
        forwarder.recive(packets); 
        auto packets_f = forwarder.forward(cur_time);
        reciver.recive(packets_f, cur_time);
        cur_time = cur_time + 2_ms; //2ms处理间隔(尽量小,来模拟&quot;时时刻刻&quot;都在处理)
    }
    sender.set_bps(kSecondStageBps);
    while(cur_time &amp;lt; kSecondStageEndTime){
        auto packets = sender.send(cur_time);
        forwarder.recive(packets); 
        auto packets_f = forwarder.forward(cur_time);
        reciver.recive(packets_f, cur_time);
        cur_time = cur_time + 2_ms;
    }
    sender.set_bps(kThirdStageBps);
    while(cur_time &amp;lt; kThirdStageEndTime){
        auto packets = sender.send(cur_time);
        forwarder.recive(packets); 
        auto packets_f = forwarder.forward(cur_time);
        reciver.recive(packets_f, cur_time);
        cur_time = cur_time + 2_ms;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以时间t为横坐标，当前延迟梯度的累计和m(t)为纵坐标:
&lt;img src=&quot;../material/GccTrendingLineFilter/trendingChange.png&quot; alt=&quot;统计图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;变化方向&quot;&gt;变化方向&lt;/h3&gt;

&lt;p&gt;对上图中的&lt;strong&gt;“曲线(实际情况中应该是曲线)”&lt;/strong&gt;求切线:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;斜率&amp;gt;0，转发设备中的缓冲队列在增大，&lt;strong&gt;如果继续保持这个速度，情况会不断恶化&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;斜率&amp;lt;0，转发设备中的缓冲队列在减小，&lt;strong&gt;如果继续保持这个速度，情况会不断改善&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线性回归&quot;&gt;线性回归&lt;/h3&gt;

&lt;p&gt;TrendingLine模块的任务就是，根据历史的数据(时间和延迟梯度和)，计算当前一小段时间内的”斜率”，也就是”变化方向”，用于给速度控制模块参考信息。&lt;/p&gt;

&lt;p&gt;线性回归过程主要解决的就是如何通过样本来获取最佳的拟合线。最常用的方法便是最小二乘法，它是一种数学优化技术，它通过最小化误差的平方和寻找数据的最佳函数匹配。&lt;/p&gt;

&lt;h4 id=&quot;最小二乘法&quot;&gt;最小二乘法&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../material/GccTrendingLineFilter/linear_regresion.png&quot; alt=&quot;linear_regresion&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代码实现&quot;&gt;代码实现&lt;/h4&gt;

&lt;p&gt;计算延迟梯度时，以5ms为间隔，对达到的数据进行分组(5ms内达到的数据为一组)，论文中是以一帧为间隔。webrtc中的代码不太好懂，我自己的实现(可能也不太好懂)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;// 对每一个到达的数据进行统计
void TrendingLineFilter::incoming_packet_feedback(int64_t send_time,
        int64_t recive_time,size_t size)
{
    (void) size;
    if(common::TimeDelta(send_time - cur_group_.first_packet_send_time) &amp;gt; kSampleGroupInterval
            &amp;amp;&amp;amp; cur_group_.initialized()){  //新的一组
        do{
            if(!prev_group_.initialized()){
                break;
            }
            //计算一组值
            assert(cur_group_.first_packet_send_time &amp;gt; 
                    prev_group_.first_packet_send_time);
            assert(cur_group_.last_packet_recive_time &amp;gt; 
                    prev_group_.last_packet_recive_time);
            int64_t send_time_delta = cur_group_.first_packet_send_time 
                            - prev_group_.first_packet_send_time;
            int64_t recive_time_delta = cur_group_.last_packet_recive_time 
                            - prev_group_.last_packet_recive_time;

            int64_t delta_us = recive_time_delta - send_time_delta;

            insert_new_sample_and_update(delta_us,recive_time);
            detect(send_time_delta,recive_time);
            //...
        } while(false);
        prev_group_ = cur_group_;
        cur_group_ = TimestampGroup();
    }
    if(cur_group_.first_packet_send_time &amp;gt; 0){
        cur_group_.first_packet_send_time = std::min(cur_group_.first_packet_send_time, send_time);
    }
    else{
        cur_group_.first_packet_send_time = send_time;
    }
    cur_group_.last_packet_recive_time = std::max(cur_group_.last_packet_recive_time, recive_time);
    
}

void TrendingLineFilter::insert_new_sample_and_update(int64_t delta_us,int64_t complete_time_us)
{
    const int64_t delta_ms = std::lround(delta_us * 1.0 / 1000);
    int64_t complete_time_ms = std::lround(complete_time_us * 1.0 / 1000);
    first_arrive_time_ms_ = std::min(first_arrive_time_ms_, complete_time_ms);
    acc_delay_ += delta_ms;
    num_delay_delta_ ++;
    num_delay_delta_ = std::min&amp;lt;int64_t&amp;gt;(num_delay_delta_,1000);
    smoothed_delay_ =  smooth_coeff_ * smoothed_delay_ + (1 - smooth_coeff_) * acc_delay_;
    sample_points_.push_back(
            {   //由于是&quot;差&quot;，所以每一组数据都不会非常大，数值不会溢出，可以放心用于后续的数学计算
        complete_time_ms - first_arrive_time_ms_,
                smoothed_delay_
            });
    if(sample_points_.size() &amp;gt;= window_size_) {
        /**@explain:
         *  trend 可以认为是对当前网络状态的一个反映 : (send_rate - capacity) / capacity;
         *  trend &amp;gt; 0,网络的排队延迟正在朝着增大的方向发展
         *  trend &amp;lt; 0,网络的排队延迟正在朝..减少........
         *  trend = 0,没有变化
         */
        cur_trend_ = linear_regresion();
        sample_points_.pop_front();
    }
}
// 根据数据公式进行计算
double TrendingLineFilter::linear_regresion()
{
    assert(sample_points_.size() == window_size_);
    double trend = cur_trend_;
    double sum_x = 0;
    double sum_y = 0;
    //TODO: 在求平均数这个事情上可以有优化的措施
    //但是意义并不大
    for (const auto&amp;amp; point : sample_points_) {
        sum_x += point.x;
        sum_y += point.y;
    }
    double x_avg = sum_x / sample_points_.size();
    double y_avg = sum_y / sample_points_.size();
    double numerator = 0;
    double denominator = 0;
    for (const auto&amp;amp; point : sample_points_) {
        numerator += (point.x - x_avg) * (point.y - y_avg);
        denominator += (point.x - x_avg) * (point.x - x_avg);
    }
    //TODO:C++17 的optional 可以用在分母为0的处理
    if( denominator != 0 ){
        trend = numerator / denominator;
    }
    return trend;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;联系我&quot;&gt;联系我&lt;/h3&gt;

&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Jun 2019 10:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//GccTrendlineFilter/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//GccTrendlineFilter/</guid>
        
        
        <category>network,gcc,udp</category>
        
      </item>
    
      <item>
        <title>总结c++中的cast</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;此文算是一个notes，总结一下C++中的各类cast用法和原理。&lt;/p&gt;
&lt;h3 id=&quot;static_cast&quot;&gt;static_cast&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;总结:反转一个定义良好的隐式类型转换&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;static_cast 执行关联类型之间的转换，比如一种指针类型向同一个类层次中其它指针类型的转换，或者整数类型向枚举类型的转换，或者浮点类型向整数类型的转换。它还能执行构造函数和转换运算符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;同一类层次&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class B{
};
class D : public B{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B和D就叫做同一个类层次。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;char* ptr_c = nullptr;
int* ptr_i = static_cast&amp;lt;int*&amp;gt;(ptr_c); //编译失败
B* ptr_b = new B();
D* ptr_d = ptr_b; //编译失败
D* ptr_d = static_cast&amp;lt;D*&amp;gt;(ptr_b); //fine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，down_cast是没有任何保证的，程序员必须明白会发生什么事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;整数类型向枚举类型的转换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;enum class E : uint8_t{
    kValue = 1
};
uint8_t v = E::kValue ; //编译失败
uint8_t v = static_cast&amp;lt;uint8_t&amp;gt;(E::kValue); //fine
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;const_cast&quot;&gt;const_cast&lt;/h3&gt;
&lt;p&gt;const_cast&lt;type&gt;(expression)&lt;/type&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;参与转换的类型仅在const修饰符及volatile修饰符上有所区别&lt;/strong&gt;，除此以外new_type和expression的类型是一样。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;常量指针被转化成非常量的指针，并且仍然指向原来的对象。&lt;/li&gt;
    &lt;li&gt;常量引用被转化成非常量的引用，并且仍然指向原来的对象。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/h3&gt;
&lt;p&gt;dynamic_cast&amp;lt;type*&amp;gt;(e) 执行指针或者引用向类层次体系的类型转换，并执行运行时检查。&lt;/p&gt;

&lt;p&gt;不管是向上或者向下或者向左右都可以调用dynamic_cast。&lt;/p&gt;

&lt;p&gt;对于upcast，可以但没必要，向上塑性直接写就完事儿了。&lt;/p&gt;

&lt;h3 id=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/h3&gt;
&lt;p&gt;reinterpret_cast&lt;type&gt;(expression)&lt;/type&gt;&lt;/p&gt;

&lt;p&gt;这玩意就用的比较少了，和static_cast不一样，只有以下情况可以使用reinterpret_cast:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.表达式是整形、枚举、指针、或者成员指针&lt;/li&gt;
  &lt;li&gt;2.指针和整形互转&lt;/li&gt;
  &lt;li&gt;3.T1* 可以和 T2* 互转&lt;/li&gt;
  &lt;li&gt;4.T1左值可以转化为T2引用&lt;/li&gt;
  &lt;li&gt;5.函数指针可以随便转，不用管类型。这里的函数指针包括类成员函数。
相对与static_cast的区别，有以下一个例子:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class A {
    public:
    int m_a;
};
class B {
    public:
    int m_b;
};
class C : public A, public B {};

C c;
printf(&quot;%p, %p, %p&quot;, &amp;amp;c, reinterpret_cast&amp;lt;B*&amp;gt;(&amp;amp;c), static_cast &amp;lt;B*&amp;gt;(&amp;amp;c));
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量，并将之转换到正确的地址（c里面有m_a,m_b，转换为B*指针后指到m_b处），而reinterpret_cast却不会做这一层转换。因此, 你需要谨慎使用 reinterpret_cast。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;static_pointer_cast&quot;&gt;static_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;dynamic_pointer_cast&quot;&gt;dynamic_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;const_pointer_cast&quot;&gt;const_pointer_cast&lt;/h3&gt;

&lt;h3 id=&quot;reinterpret_cast-1&quot;&gt;reinterpret_cast&lt;/h3&gt;

&lt;p&gt;总结上述4个:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; static_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    auto p = static_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get());
    return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
}

template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; dynamic_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    if (auto p = dynamic_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get())) {
        return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
    } else {
        return std::shared_ptr&amp;lt;T&amp;gt;();
    }
}

template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; const_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    auto p = const_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get());
    return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
}

template&amp;lt; class T, class U &amp;gt; 
std::shared_ptr&amp;lt;T&amp;gt; reinterpret_pointer_cast( const std::shared_ptr&amp;lt;U&amp;gt;&amp;amp; r ) noexcept
{
    auto p = reinterpret_cast&amp;lt;typename std::shared_ptr&amp;lt;T&amp;gt;::element_type*&amp;gt;(r.get());
    return std::shared_ptr&amp;lt;T&amp;gt;(r, p);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 11 Mar 2019 12:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//cppcastall/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//cppcastall/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>AT&amp;T汇编摘记</title>
        <description>&lt;h3 id=&quot;0-寄存器&quot;&gt;0. 寄存器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通用寄存器&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;共有16个通用寄存器，如下图所示:
&lt;img src=&quot;../material/X86_64ASSEMBLY/general_register.png&quot; alt=&quot;generalRegister&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Segment Register&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;CS:存放程序在内存中的基地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;DS:数据段地址(.data?)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;SS:存放栈的段地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;SP:存放栈的偏移地址&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;ES:扩展的段寄存器(不够用了可以用这个)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;«Linux 0.11完全注释»P90有关于这个的介绍&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指令指针寄存器(EIP)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;远跳转:在分段模式下，当跳转到另一个段中的指令时&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;短跳转:当跳转偏移量小于128字节时&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;近跳转:除1,2外的所有其它跳转
&lt;strong&gt;堆栈指针寄存器(ESP)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;0.指向栈顶&lt;/li&gt;
  &lt;li&gt;1.函数调用:通常和EBP一起配合使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1-数据段&quot;&gt;1. 数据段&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数据段(.data),以及.bss段&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//code1
int main()
{
    return 0;
}
//code2
int a;
int main()
{
    return 0;
}
//code3
int a = 0;
int main()
{
    return 0;
}
int a = 1;
int main()
{
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;code1\2\3的text data bss大小一样，code4的data段比123多4字节，bss段比123少4字节。&lt;/p&gt;

&lt;p&gt;这说明：
&lt;em&gt;被显式初始化、且初值不为0的全局变量存放于.data段，为初始化的全局变量或者初始化为0的全局变量存放与.bss段。&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//code11
int main()
{
    return 0;
}
//code12
static int i;
int main()
{
    return 0;
}
//code13 
static int i = 0;
int main()
{
    return 0;
}
//code 14
static int i = 1;
int main()
{
    return 0;
}
//code 15
int main()
{
    static int i ;
    return 0;
}
//code 16
int main()
{
    static int i = 0;
    return 0;
}
//code 17
int main()
{
    static int i = 1;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对与static修饰的变量，从&lt;strong&gt;存放位置&lt;/strong&gt;看，和全局变量没有任何区别:不管在局部静态变量还是全局静态变量，都按照全局变量处理。
&lt;strong&gt;text 代码段&lt;/strong&gt;
没啥好说的。&lt;/p&gt;

&lt;p&gt;段寄存器CS和DS用于包含代码段和数据段的地址，CS + EIP（段中偏移）就可以获取指令码的地址。
这里不做详细的介绍，«Linux0.11»中介绍了段管理的具体细节。&lt;/p&gt;

&lt;h3 id=&quot;2-函数&quot;&gt;2. 函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;声明函数&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pushl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;movl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#code from here
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;movl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;popl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;堆栈情况:
&lt;img src=&quot;../material/X86_64ASSEMBLY/stack_overview.png&quot; alt=&quot;stackOverview&quot; /&gt;
解释：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当执行到bar(1,2)时，现将2,1参数压人堆栈然后将”return”语句的地址压入堆栈，但是为了避免在bar中出现push,pop等操作把返回地址给弄丢了，使用另外一个寄存器:ebp来存放’esp’的地址，当然还需要保存旧的ebp地址。所以函数的首部和尾部就长成了上述这样。(«汇编预言程序设计» P245)&lt;/p&gt;

&lt;p&gt;还剩最后一个问题，如果函数把任何数据都压入堆栈，ESP寄存器仍然指向局部变量被存放之前的位置，并且将覆盖这些变量。为了解决这个问题，需要在函数开始的位置预留一定数量的栈空间。&lt;/p&gt;

&lt;h3 id=&quot;3链接&quot;&gt;3.链接&lt;/h3&gt;
&lt;p&gt;一段程序包含.text .data .bss 段链接器会将所有的目标文件的这些段合并在一块。
&lt;img src=&quot;../material/X86_64ASSEMBLY/link_object.png&quot; alt=&quot;ldOverview&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//att_assembly_manaul/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//att_assembly_manaul/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Linux 0.11运行机制</title>
        <description>&lt;hr /&gt;

&lt;p&gt;这将是一个漫长的过程，终将解答我心中的疑惑….&lt;/p&gt;
&lt;h3 id=&quot;step-0-启动阶段&quot;&gt;step 0: 启动阶段&lt;/h3&gt;
&lt;h4 id=&quot;磁盘引导&quot;&gt;磁盘引导&lt;/h4&gt;
&lt;p&gt;PC加电后，BIOS将引导扇区加载到内存0x7C00处(为什么是这个地址?是个业内约定)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;引导扇区:

Boot sector(引导扇区)是所有存储介质上的第一个扇区，大小为512字节。主要分为三个部分，分别是:
* 1. MBR(master boot record,主引导记录) 445字节
* 2. DPT(disk partition table,磁盘分区表) 64字节
* 3. BRID(boot record ID 引导记录标示) 2字节
#### MBR 
主引导记录的作用是安装基本的引导加载程序(boot loader),在Linux中是grub。grub的主要功能是：
* 1. 提供菜单：用户可以选择不同的开机选项，这是多重引导的虫咬功能。
* 2. 载入内核文件: 直接指向可开机的程序区段来开始操作系统
* 3. 转交其它Loader: 将引导加载功能交给其它loader处理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bootsect.s 是第一个被CPU执行的程序，这个程序先把自己从移动到0x90000处，接在吧磁盘中的setup.s弄到内存里来（具体的位置是0x920000)，然后把system模块移动到0x10000处，跳转到setup程序，setup.s程序又将system模块移动到内存起始地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bootsect.s,setup.s 为什么要移来移去的？

我们的目标是要将操作系统放到内存里去，最好的位置就是内存起始地址(0x0000)，但是在刚开始的时候，BIOS在那个内存起始处保存了中断向量和终端服务程序，所以在仍然需要用到BIOS功能之前我们不能直接将系统移动到那个地方去。

为什么是0x900000?

那时候system模块挺小的，0x0000000 ---- 0x900000 足够放置system模块代码。 

为什么是0x10000？

BIOS相关的的东西在 0x000000 --- 0x10000中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gdtldtrdt表&quot;&gt;gdt,ldt,rdt表&lt;/h3&gt;

&lt;p&gt;setup.s 做了一系列的操作中，最重要的当然是这三个表的初始化，设置好代码段、数据段后程序就可以跑起来了,具体的细节涉及到”X86保护模式以及编程”。setup.s调用head.s代码，执行完后内存映像如下：
&lt;img src=&quot;../material/Linux011/heads.png&quot; alt=&quot;head.s内存映像&quot; /&gt;
注：页表、描述符表等的初始化在head.s代码中&lt;/p&gt;

&lt;h3 id=&quot;内核初始化mainc程序&quot;&gt;内核初始化main.c程序&lt;/h3&gt;

&lt;h4 id=&quot;trap_init&quot;&gt;trap_init()&lt;/h4&gt;

&lt;p&gt;Linux0.11 用过门描述符在idt表中放置了各种异常处理函数(具体操作是traps.c:trap_inti())，包括：除0，段错误等。当异常发生的时候，根据idt表中的段选择符找到中断处理函数，执行相应的处理回调，以除0为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;
#首先进入中断处理(涉及各类寄存器的处理，具体原理要看&quot;X86保护模式及其编程&quot;)，执行asm.s中的&quot;divide_error&quot;:

divide_error:
	pushl $do_divide_error # 接下来被调用
no_error_code:
	xchgl %eax,(%esp)      #寄存器处理
	pushl %ebx
	pushl %ecx
	pushl %edx
    ...
    ...
    iret                  #返回后，CS:EIP 可能已经被改变

void do_divide_error(long esp, long error_code)
{
	die(&quot;divide error&quot;,esp,error_code);
}

static void die(char * str,long esp_ptr,long nr)
{
	long * esp = (long *) esp_ptr;
	int i;

	printk(&quot;%s: %04x\n\r&quot;,str,nr&amp;amp;0xffff);
	printk(&quot;EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n&quot;,
		esp[1],esp[0],esp[2],esp[4],esp[3]);
	printk(&quot;fs: %04x\n&quot;,_fs());
	printk(&quot;base: %p, limit: %p\n&quot;,get_base(current-&amp;gt;ldt[1]),get_limit(0x17));
	if (esp[4] == 0x17) {
		printk(&quot;Stack: &quot;);
		for (i=0;i&amp;lt;4;i++)
			printk(&quot;%p &quot;,get_seg_long(0x17,i+(long *)esp[3]));
		printk(&quot;\n&quot;);
	}
	str(i);
	printk(&quot;Pid: %d, process nr: %d\n\r&quot;,current-&amp;gt;pid,0xffff &amp;amp; i);
	for(i=0;i&amp;lt;10;i++)
		printk(&quot;%02x &quot;,0xff &amp;amp; get_seg_byte(esp[1],(i+(char *)esp[0])));
	printk(&quot;\n\r&quot;);
	do_exit(11);		/* play segment exception */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见默认的处理就是”打印出错地址，杀死当前进程”，然后重新调度起另一个进程(do_exit()中)。&lt;/p&gt;

&lt;h3 id=&quot;system_call&quot;&gt;system_call&lt;/h3&gt;

&lt;p&gt;系统调用是使用0x80中断，具体的原理是:在idt表中的第0x80(124)个索引中存放了一个DPL=3的陷进门(sched_init函数中)，所以用户态代码可以以特权级别3（DPL&amp;lt;=MIN(CPL,RPL))来访问这个陷进门。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set_system_gate(0x80,&amp;amp;system_call);

//dpl = 3 , 所以用户态代码可以通过这个门进入内核
//type = 15 陷阱门
#define set_system_gate(n,addr) \
	_set_gate(&amp;amp;idt[n],15,3,addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在system_call中根据系统调用号来决定调用哪一个系统调用函数，每个系统调用函数都存放在一个函数指针数组：sys_call_table中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;system_call:   
	cmpl $nr_system_calls-1,%eax
	ja bad_sys_call
	push %ds
	push %es
	push %fs
	pushl %edx
	pushl %ecx		# push %ebx,%ecx,%edx as parameters
	pushl %ebx		# to the system call
	movl $0x10,%edx		# set up ds,es to kernel space
	mov %dx,%ds
	mov %dx,%es
	movl $0x17,%edx		# fs points to local data space
	mov %dx,%fs
	call sys_call_table(,%eax,4)  #执行具体的系统调用
	pushl %eax
	movl current,%eax
	cmpl $0,state(%eax)		# state
	jne reschedule
	cmpl $0,counter(%eax)		# counter
	je reschedule       # 重新调度
ret_from_system_call:   # 在这里处理了&quot;信号处理句柄&quot;
    ...
    ...
    iret                # 可见，先处理信号（如果有的话），在执行用户程序
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;信号处理&quot;&gt;信号处理&lt;/h3&gt;
&lt;p&gt;任务的数据结构中信号部分:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;struct task_struct {
    ...
    long blocked;	/*信号屏蔽码*/
	long signal;    /*当前发生的信号*/
	struct sigaction sigaction[32];
    ...
}

struct sigaction {
	void (*sa_handler)(int);  /*信号回调*/
	sigset_t sa_mask;         /*执行回调时的信号屏蔽码*/
	int sa_flags;             
	void (*sa_restorer)(void);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;//进程A向进程B发送信号(sig)
//第一步是调用对应的系统调用，正真的执行函数如下：
//p 是对应的进程的任务结构指针
static inline int send_sig(long sig,struct task_struct * p,int priv)
{
	if (!p || sig&amp;lt;1 || sig&amp;gt;32)
		return -EINVAL;
	if (priv || (current-&amp;gt;euid==p-&amp;gt;euid) || suser())
		p-&amp;gt;signal |= (1&amp;lt;&amp;lt;(sig-1));  //将指定进程的signal添加sig信号标记
	else
		return -EPERM;
	return 0;
}
//进程B执行系统调用(不管是主动还是被动，总是要执行)，将要返回的时候，会执行do_signal函数:
ret_from_sys_call:
	movl current,%eax		# task[0] cannot have signals
	cmpl task,%eax
	je 3f
	cmpw $0x0f,CS(%esp)		# was old code segment supervisor ?
	jne 3f
	cmpw $0x17,OLDSS(%esp)		# was stack segment = 0x17 ?
	jne 3f
	movl signal(%eax),%ebx
	movl blocked(%eax),%ecx
	notl %ecx
	andl %ebx,%ecx
	bsfl %ecx,%ecx
	je 3f
	btrl %ecx,%ebx
	movl %ebx,signal(%eax)
	incl %ecx
	pushl %ecx
	call do_signal    # 看下当前有没有人给我发送了信号
    ...
    iret
//do_signal函数比较复杂，主要作用是将信号处理函数(sa_handler)插入到用户态堆栈中去而不是在内核态运行
//这里比较奇妙
void do_signal(long signr,long eax, long ebx, long ecx, long edx,
	long fs, long es, long ds,
	long eip, long cs, long eflags,
	unsigned long * esp, long ss)
{
	unsigned long sa_handler;
	long old_eip=eip;
	struct sigaction * sa = current-&amp;gt;sigaction + signr - 1;
	int longs;
	unsigned long * tmp_esp;

	sa_handler = (unsigned long) sa-&amp;gt;sa_handler;
	if (sa_handler==1)
		return;
	if (!sa_handler) {
		if (signr==SIGCHLD)
			return;
		else
			do_exit(1&amp;lt;&amp;lt;(signr-1));
	}
	if (sa-&amp;gt;sa_flags &amp;amp; SA_ONESHOT)
		sa-&amp;gt;sa_handler = NULL;
	*(&amp;amp;eip) = sa_handler;
	longs = (sa-&amp;gt;sa_flags &amp;amp; SA_NOMASK)?7:8;
	*(&amp;amp;esp) -= longs;
	verify_area(esp,longs*4);
	tmp_esp=esp;
	put_fs_long((long) sa-&amp;gt;sa_restorer,tmp_esp++);
	put_fs_long(signr,tmp_esp++);
	if (!(sa-&amp;gt;sa_flags &amp;amp; SA_NOMASK))
		put_fs_long(current-&amp;gt;blocked,tmp_esp++);
	put_fs_long(eax,tmp_esp++);
	put_fs_long(ecx,tmp_esp++);
	put_fs_long(edx,tmp_esp++);
	put_fs_long(eflags,tmp_esp++);
	put_fs_long(old_eip,tmp_esp++);
	current-&amp;gt;blocked |= sa-&amp;gt;sa_mask;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数的具体原理其实也没必要去理解(还是那句话’x86原理’)，执行效果如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../material/Linux011/do_signal.png&quot; alt=&quot;在用户堆栈中运行&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有相关的sys_signal\sys_sigaction比较简单，只是简单的修改一下任务结构中的值。&lt;/p&gt;

&lt;h3 id=&quot;exitc-文件&quot;&gt;exit.c 文件&lt;/h3&gt;

&lt;p&gt;这里是基于信号的一些应用函数，比如sys_exit()，tell_father()，sys_wait()等，略。&lt;/p&gt;

&lt;h3 id=&quot;forkc-文件&quot;&gt;fork.c 文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fork()函数是用户态的API接口，最终会展开为一段包含int 0x80这个编程异常指令以及movl eax, res; return res的汇编代码，从而触发编程异常，从用户态进入内核，执行system_call异常处理函数。

而system_call通过保存在eax寄存器中的系统调用号会去调用内核中真正实现fork功能的系统调用sys_fork。

sys_fork要做的工作首先是为新创建的子进程找到一个可用的pid，即last_pid。然后调用copy_process复制父进程的pcb数据到子进程的pcb。当然复制完成后要做一些修改，把子进程的父进程号设置为当前调用fork()API的父进程，同时将子进程tss结构体中的eax寄存器的值设置为0。并将子进程的状态设置为就绪态，从而使得子进程后面可以得到CPU的调度。再进行其他一些数据复制和处理以后，sys_fork函数返回到异常处理函数system_call，返回值为子进程的pid即last_pid。

system_call检查父进程是否需要重新调度。如果需要再次调度，则执行调度。否则system_call将系统调用sys_fork的返回值存入寄存器eax中，执行异常返回操作从内核返回到用户态，接着从父进程int 0x80后的下一条指令开始执行，也就是执行movl eax, res; return res，这就实现了父进程从fork() API调用的返回，返回值就是保存在eax寄存器的last_pid。如果system_call执行调度，父进程就会被换入到就绪队列中，失去CPU的使用权。那么可能是子进程也可能是其他进程继而得到CPU的使用权，开始执行。

总之，子进程总会有执行的时刻，而子进程的pcb中的cs,eip寄存器保存的是和父进程通过int 0x80编程异常进入内核处理函数时一样的指令地址，即子进程也是从int 0x80后面的指令movl eax, res; return res开始执行，而子进程的eax的值被设置为0，从而子进程开始执行时的指令流程，和父进程从异常处理函数system_call返回到用户空间后的执行流程是一样的，将eax的值作为fork()API的返回值，从而完成子进程像是从fork()API返回的样子，但实质只是其执行流程是从fork()API返回处开始执行的，且返回值是0。而父进程不管是不经过调度先进入内核执行sys_fork系统调用，再从内核返回到fork()API，再从fork()API返回；还是经过调度被换出后进入等待队列，到再次得到CPU开始执行，两者的指令的执行流程都是一样。综上，父进程和子进程都要执行，返回值也不一样，所以fork()API表现为一次调用两次返回，但实质任何函数调用都只会返回一次，父进程是返回，而子进程只是从父进程的返回指令处开始执行。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;写时拷贝的原理:
根本原因还是在于只为子进程分配了”虚拟地址空间”，且父子进程的虚拟地址空间指向同一段物理内存。并为这些页面设置”不可写”,如果有任何一方试图对这些页面进行写操作，就会触发写保护异常，此时才真正执行内存分配操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void write_verify(unsigned long address)
{
	unsigned long page;

	if (!( (page = *((unsigned long *) ((address&amp;gt;&amp;gt;20) &amp;amp; 0xffc)) )&amp;amp;1))
		return;
	page &amp;amp;= 0xfffff000;
	page += ((address&amp;gt;&amp;gt;10) &amp;amp; 0xffc);
	if ((3 &amp;amp; *(unsigned long *) page) == 1)  /* non-writeable, present */
		un_wp_page((unsigned long *) page);
	return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;文件系统&quot;&gt;文件系统&lt;/h3&gt;

&lt;h3 id=&quot;块设备驱动&quot;&gt;块设备驱动&lt;/h3&gt;

&lt;h3 id=&quot;字符设备驱动&quot;&gt;字符设备驱动&lt;/h3&gt;
</description>
        <pubDate>Fri, 11 Jan 2019 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//os_study/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//os_study/</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>字符串编码</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;一直以来，字符串编码总是我摸不着头脑。对待字符串编码问题的策略也是简单粗暴，直接规避：一律使用utf-8。但是，猿在码界漂，哪能不挨刀。今天就总结一下字符串编码问题。&lt;/p&gt;
&lt;h3 id=&quot;编码类型介绍&quot;&gt;编码类型介绍&lt;/h3&gt;
&lt;h4 id=&quot;ascii&quot;&gt;ascii&lt;/h4&gt;
&lt;p&gt;编码格式花样很多。由于计算机是老美发明的，因此，最早只有127个字符被编码到计算机中，着127个字符被称为ascii编码集。由于ascii字符集只有127个字符，故只要一个字节就可以表示。&lt;/p&gt;

&lt;h4 id=&quot;else&quot;&gt;else&lt;/h4&gt;
&lt;p&gt;但是，世界上那么多国家、那么多语言，全世界人民都想体验一把先进文化，于是八仙过海，各显神通，日本把日文编码到Shift-jis中，韩国把韩文编码到Euc-kr中。我们国家陆续有gb2312、gbk、gb18030，后者都是对前者的扩展。拿我们汉字举例，汉字有成千上万个，所以一个字节表示不了那么多的汉字，所以就需要多个字节(2个或3个)来表示。&lt;/p&gt;
&lt;h4 id=&quot;unicode&quot;&gt;unicode&lt;/h4&gt;
&lt;p&gt;大家要是没有一套统一的编码格式的话，还怎么促进文化的交流、各国码农感情的培养。于是，unicode应运而生，unicode把所有语言都统一到一套编码中，这样大家就可以顺畅的交流了。为了表示那么多的语言，unicode也只能采用多字节表示法，就是一个字符用多个字节的数据表示。&lt;/p&gt;

&lt;p&gt;于是，新的问题又出现了。对于大部分西方国家，他们使用的英语，一个字节就可以表示一个字符。如果使用unicode，那岂不是很浪费空间。于是又有人想出来了一种更佳妙的方式：对unicode继续编码。（可以理解成对unicode压缩编码）&lt;/p&gt;

&lt;p&gt;也就说，utf-8,utf-16,utf-32是在unicode基础上，对unicode再次编码。&lt;/p&gt;

&lt;p&gt;以UTF-8来说：UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;字符&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ascii&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;unicode&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;utf-8&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;A&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;00000000 01000001&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;?&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;01001110 00101101  11100100 10111000&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10101101&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这么多编码格式，大家的一个共同点就是：完全对ascii码兼容。也就是说ascii中的’a’，和gb2312中的’a’是同样的表示方法(假设是0x63)。&lt;/p&gt;

&lt;h3 id=&quot;实际环境&quot;&gt;实际环境&lt;/h3&gt;
&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;如果您是在linux上开发，通常是碰不到这些问题的。(没错，我就是舔狗)&lt;/p&gt;

&lt;p&gt;在Linux上，系统默认就是utf-8格式。这是什么意思？&lt;/p&gt;

&lt;p&gt;举例来说，当你 “touch main.cpp” 这个文件就是采用的utf-8来编码里面的所有数据。
当你&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个pstr中的内容就会以utf-8格式存储。
当你:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;g++ main.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; a.out
&amp;amp; ./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;编译器会忠于你的文件编码格式，按此编码格式处理该源文件。pstr中的内容会被取出来放在内存中，并以utf-8格式输出在终端环境上。终端能不能正常显示，就看你的终端能不能支持utf-8。&lt;/p&gt;

&lt;p&gt;任何的字符串乱码问题，就是上面这三种中的某一个或多个编码格式不一样导致。&lt;/p&gt;
&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;在windows上，呵呵呵了。中文windows默认采用gb2312格式。&lt;/p&gt;

&lt;p&gt;举例来说。当你”新建一个文件”，这个文件通常是gb2312格式，如果这个文件只在本地使用，这时候通常是没问题的。&lt;/p&gt;

&lt;p&gt;但是当你因为某些原因需要使用在windows上使用”unicode”，问题就来了。
还是以上面main.cpp为例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.如果main.cpp为gb2312，用vs编译，pstr为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;2.如果main.cpp为纯unicode，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
  &lt;li&gt;3.如果main.cpp为utf-8(无bom)，用vs编译，pstr在内存里为utf-8格式，但是终端显示不了中文。&lt;/li&gt;
  &lt;li&gt;4.如果main.cpp为utf-8(bom)，用vs编译，pstr在内存里为gb2312格式，终端可以显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到了吧，vs的”睿智”。这个问题如果搭配上”wchar_t”，更加让人恼火。&lt;/p&gt;

&lt;p&gt;上面的测试可以采用如下程序：&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%x,&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstring&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;abc中文ABC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将结果和各个编码表进行对照，既可得出结论。&lt;/p&gt;

&lt;p&gt;在unicode方面，对windows的批评滔滔不绝，”utf-8 everywhere”认为微软在字符串处理上误入歧途，因为他们比别的厂商更早做了决定。微软虽然有理由说，windows先于unicode问世。但是这么多年过去了，windows的API还是不完全支持unicode。&lt;/p&gt;

&lt;p&gt;windows不遵守基本法，也不是一天两天了，嘻嘻。&lt;/p&gt;

&lt;p&gt;关于如何在windows处理utf-8，以及对windwos的更多批评，可以从这篇文章起步: &lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt; “&lt;/p&gt;
&lt;h3 id=&quot;char与wchar_tstring与wstring&quot;&gt;char与wchar_t，string与wstring&lt;/h3&gt;
&lt;p&gt;如果您不幸遇到了string和wstring方便的困扰，恭喜您。&lt;/p&gt;

&lt;p&gt;首先，std::string 和 std::wstring都继承与std::basic_string。
只不过std::string的模板参数是char，std::wstring的模板参数是wchar_t。
在linux上，wchar_t占用4个字节，windows上则是占用2个字节。他们之间的差别，&lt;strong&gt;仅此而已。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你如果使用wstring存放字符串，Linux是没有啥问题的，采用utf-32编码wstring。&lt;/p&gt;

&lt;p&gt;但是如果是windows上，嘻嘻，问题又来了。假设在main.cpp中存放了一个std::wstring = “abc中文”,那么：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.a.cpp如果是gb2312格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;2.a.cpp如果是unicode格式，wstring在内存中是unicode格式。&lt;/li&gt;
  &lt;li&gt;3.a.cpp如果是utf-8格式，wstring在内存中是ucs-2be格式。&lt;/li&gt;
  &lt;li&gt;4.a.cpp如果是utf-8-bom格式，wstring在内存中是unicode格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;您肯定还有一个疑惑，&lt;strong&gt;关于wstring和string之间的互相转换&lt;/strong&gt;。
那么，您需要确保你非常了解待转换的数据的格式，或者待转换数据仅来自本地。&lt;/p&gt;

&lt;p&gt;在windows上，windows有一个奇技淫巧：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WideCharToMultiByte系列API，通过参数设定你就可以获得你所希望的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详见windows api说明，如何正确使用，请看： &lt;a href=&quot;https://stackoverflow.com/questions/215963/how-do-you-properly-use-widechartomultibyte&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，c++标准库也可以做到：std::locale、std::codecvt结合使用。&lt;/p&gt;

&lt;h3 id=&quot;帮组文档&quot;&gt;帮组文档&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://utf8everywhere.org/zh-cn#faq.almostfw&quot;&gt;utf8 everywhere&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/benkaoya/article/details/59522148&quot;&gt;潜谈C/C++编程中的字符编码转换&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/ybusad/blog/363139&quot;&gt;C++字符编码问题探究和中文乱码的产生&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;获得帮助&quot;&gt;获得帮助&lt;/h3&gt;
&lt;p&gt;meemetao@gmail.com&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Nov 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//string-coding/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//string-coding/</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>C++成员函数指针的大小</title>
        <description>&lt;hr /&gt;

&lt;h3 id=&quot;c中的函数指针假定在64位机器上&quot;&gt;c++中的函数指针(假定在64位机器上)&lt;/h3&gt;

&lt;p&gt;我们知道指针的大小恒定的,跟机器位数有关,32位机下,指针是4字节大小,64位机下指针是8字节大小.但是在C++中,有一个比较特殊的地方是C++的类成员函数
指针,它的大小是普通指针的2倍.先看一个实例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void foo(void)
{
}
class A{
public:
    void foo(){}
}

int main()
{
    void (*pfun)(void);
    pfun = foo;
    void (A::*pMfun)(void);
    pMfun = &amp;amp;A::foo;
    std::cout&amp;lt;&amp;lt;&quot;normal function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pfun)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&quot;member function pointer size:&quot;&amp;lt;&amp;lt;sizeof(pMfun)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;normal &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:8
member &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;pointer size:16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;证明完毕.下面解释为什么会这样.&lt;/p&gt;
&lt;h3 id=&quot;this指针的调整&quot;&gt;this指针的调整&lt;/h3&gt;

&lt;p&gt;再看一个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;class A{
public;
    void foo()
    {
        //假设我们需要在这里去使用数组a
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
private:
    int a[4];
};
class B{
public:
    void bar()
    { 
        //假设我们需要在这里去使用数组b
        std::cout&amp;lt;&amp;lt;&quot;addr of this:%x&quot;&amp;lt;&amp;lt;this&amp;lt;&amp;lt;std::endl;
    }
prviate:
    int b[4];
};
class C: public A,B{

};

int main()
{
    C c; 
    c.foo();
    c.bar();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addr of this:%x0x7ffd30f4ec00
addr of this:%x0x7ffd30f4ec10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候可以看到,传递给foo和bar函数的this指针是不一样的?为什么会不一样呢? 考虑一下函数中的注释.
所以调用类成员函数指针时,就需要将this指针进行调整,这个调整的信息在哪里?就在这个函数指针中,所以就需要另外的空间去存放这些信息,这也就是为什么类成员函数指针是16字节的原因,因为多出来的8字节,用于编译期的this指针调整.&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Jul 2018 17:13:17 +0800</pubDate>
        <link>http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</link>
        <guid isPermaLink="true">http://MemeTao.github.io//theSizeOfMemeberFunctionPointer/</guid>
        
        
        <category>c++</category>
        
      </item>
    
  </channel>
</rss>
